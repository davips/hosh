<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>hosh.hosh_ API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>hosh.hosh_</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#  Copyright (c) 2021. Davi Pereira dos Santos
#  This file is part of the hosh project.
#  Please respect the license - more about this in the section (*) below.
#
#  hosh is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  hosh is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with hosh.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
#
#  (*) Removing authorship by any means, e.g. by distribution of derived
#  works or verbatim, obfuscated, compiled or rewritten versions of any
#  part of this work is illegal and unethical regarding the effort and
#  time spent here.
from functools import reduce
from operator import mul, add
from sys import maxsize
from typing import Union

from hosh.config import GLOBAL
from hosh.groups import UT40_4, groups
from hosh.misc.colors import ansi2html, id2ansi, id2rgb
from hosh.misc.core import cells_id_fromblob, cells_fromid, id_fromcells
from hosh.misc.encoding.base777 import b777enc
from hosh.misc.exception import (
    WrongContent,
    DanglingEtype,
    CellValueTooHigh,
    WrongIdentifier,
    ElementTooHigh,
    WrongVersion,
)
from hosh.misc.math import cellsmul, cellsinv, cells2int, int2cells, cellspow, cellsroot
from hosh.theme import HTML, ANSI, BW

class Hosh:
    r&#34;&#34;&#34;
    Operable hash.

    Generate a Hosh object from a binary content or a list of 6 ints.

    Usage:

    &gt;&gt;&gt; from hosh import Hosh
    &gt;&gt;&gt; a = Hosh(b&#34;lots of data&#34;)
    &gt;&gt;&gt; b = Hosh(b&#34;lots of data 2&#34;)
    &gt;&gt;&gt; a.id
    &#39;.-0byLo.CdKjKN6RFTYqBIy30OST3oLyjYPf.6p8&#39;
    &gt;&gt;&gt; b.id
    &#39;SXBse5Ie-yUCa7h7gZiHXGkkKdispqxlc4FnCYit&#39;
    &gt;&gt;&gt; (a * b).id
    &#39;ALiaB9XPu.MoIwwoTPYrxqkGfVpktOgUv0tDB3IB&#39;
    &gt;&gt;&gt; (b * a).id
    &#39;gr9psTs5dYGrCCdgWMAPWM4dDDzktOgUv0tDB3IB&#39;
    &gt;&gt;&gt; a * b * ~b == a
    True
    &gt;&gt;&gt; c = Hosh(b&#34;lots of data 3&#34;)
    &gt;&gt;&gt; (a * b) * c == a * (b * c)
    True
    &gt;&gt;&gt; e = Hosh(b&#34;lots of data 4&#34;)
    &gt;&gt;&gt; f = Hosh(b&#34;lots of data 5&#34;)
    &gt;&gt;&gt; e * f != f * e
    True
    &gt;&gt;&gt; a * b != b * a
    True
    &gt;&gt;&gt; x = Hosh(b&#34;lots of data 6&#34;, &#34;hybrid&#34;)
    &gt;&gt;&gt; y = Hosh(b&#34;lots of data 7&#34;, &#34;hybrid&#34;)
    &gt;&gt;&gt; z = Hosh(b&#34;lots of data 8&#34;, &#34;unordered&#34;)
    &gt;&gt;&gt; x * y == y * x
    True
    &gt;&gt;&gt; x * a != a * x
    True
    &gt;&gt;&gt; x * z == z * x
    True
    &gt;&gt;&gt; a * z == z * a
    True
    &gt;&gt;&gt; from hosh import ø
    &gt;&gt;&gt; print(ø)  # Handy syntax using ø for identity.
    0000000000000000000000000000000000000000
    &gt;&gt;&gt; print(ø * &#34;7ysdf98ys34hg543hdf98ysdf98ysdfysdf98ysd&#34;)  # str, bytes or int are converted as id, blob or element rank.
    7ysdf98ys34hg543hdf98ysdf98ysdfysdf98ysd
    &gt;&gt;&gt; print(ø * &#34;7ysdf98ysdf98ysdf98ysdfysdf98ysdasddsa32&#34; * &#34;6gdsf76dfqwe123de8gaf87gaf87gaf87agdfa78&#34;)
    94UrdYKjCGQWdd5P.W4xvFJgc9hZpIHlhytqHkaa
    &gt;&gt;&gt; h = ø.u * b&#34;sdff&#34;
    &gt;&gt;&gt; print(h)
    f_9e1a267c8_____________________________
    &gt;&gt;&gt; x.id, (+x).id  # Making an ordered x.
    (&#39;ZN_60eec3e6c7b68087329e16b581401a6bb2b1f&#39;, &#39;6BDj3b7Mmj7n-6B8XYaP3akO7400s9FlG4AtcHTp&#39;)
    &gt;&gt;&gt; +x * y != y * +x
    True
    &gt;&gt;&gt; ++x == x
    True
    &gt;&gt;&gt; x ** y == +(+x * +y)  # a ** b is a shortcut for +(+a * +b)
    True
    &gt;&gt;&gt; x ** y != y ** x
    True
    &gt;&gt;&gt; (x ** b&#34;1&#34;) * (y ** b&#34;2&#34;) != (x ** b&#34;2&#34;) * (y ** b&#34;1&#34;)
    True
    &gt;&gt;&gt; (x ** b&#34;1&#34;) * (y ** b&#34;2&#34;) == (y ** b&#34;2&#34;) * (x ** b&#34;1&#34;)
    True
    &gt;&gt;&gt; (x ** y) // y == x
    True
    &gt;&gt;&gt; f + e - x == ø - x + e + f  # Alternative (always unordered, i.e., form an Abelian group) operation
    True
    &gt;&gt;&gt; import pickle
    &gt;&gt;&gt; d = pickle.dumps(x, protocol=5)
    &gt;&gt;&gt; d
    b&#39;\x80\x05\x95j\x00\x00\x00\x00\x00\x00\x00\x8c\x08builtins\x94\x8c\x07getattr\x94\x93\x94\x8c\nhosh.hosh_\x94\x8c\x04Hosh\x94\x93\x94\x8c\x06fromid\x94\x86\x94R\x94\x8c(ZN_60eec3e6c7b68087329e16b581401a6bb2b1f\x94\x85\x94R\x94.&#39;
    &gt;&gt;&gt; pickle.loads(d) == x
    True

    Parameters
    ----------
    content
        Binary content to be hashed, or a tuple of six integers
    etype
        ordered, hybrid, unordered
        According to the subset of the desired element: Z, H\\Z or G\\H
    version
        Group namedtuple: changes the number of digits and robustness against collisions
        UT32_4 is enough for most usages. It accepts more than 4 billion repetitions of the same operation in a row.
        UT64_4 provides unspeakable limits for operations, please see scientific paper for details.
        UT40_4 is recommended and default, since it is the most compatible with other systems (git, SHA-1, etc)
    &#34;&#34;&#34;

    _n, _id, _ansi_light, _ansi_dark = None, None, None, None
    _sansi_light, _sansi_dark, _sid, _etype, _rgb_light, _rgb_dark = None, None, None, None, None, None

    _etype_inducer, _bits, _ø = None, None, None
    _rev = None
    components_cache_size = 100

    def __init__(self, content, etype=&#34;default:ordered&#34;, version=UT40_4):
        self.version = version
        self.p, self.p4, self.p6, self.digits, self.bytes, _, _, _, _, _, _ = version
        self._composition_memo = {}
        if isinstance(content, (list, tuple)):
            content = tuple(content)
            if etype != &#34;default:ordered&#34;:
                raise DanglingEtype(f&#34;Cannot set etype={etype} when providing cells {content}.&#34;)
            if max(content) &gt;= self.p:
                raise CellValueTooHigh(f&#34;A cell value exceeds the limit for the group: {max(content)} &gt;= {self.p}&#34;)
            self.cells = content
        elif isinstance(content, bytes):
            if etype == &#34;default:ordered&#34;:
                etype = &#34;ordered&#34;
            self.cells, self._id = cells_id_fromblob(content, etype, self.bytes, self.p)
        else:
            raise WrongContent(
                f&#34;No valid content provided: {content}\n&#34; f&#34;It should be a bytes object to be hashed or a list of ints.&#34;
            )

    @property
    def ø(self):
        &#34;&#34;&#34;Identity element compatible with this Hosh object

        Usage:

        &gt;&gt;&gt; from hosh import Hosh
        &gt;&gt;&gt; (b := Hosh(b&#34;23987rg23&#34;)).id
        &#39;J5.uRTue8X4r1xu.JFkPbURVVGvTRPSFLncXdyzj&#39;
        &gt;&gt;&gt; b.etype
        &#39;ordered&#39;
        &gt;&gt;&gt; b.ø.etype
        &#39;unordered&#39;
        &gt;&gt;&gt; b.etype == b.ø.etype_inducer
        True
        &gt;&gt;&gt; b.ø.id
        &#39;0000000000000000000000000000000000000000&#39;
        &gt;&gt;&gt; (b.ø * b&#34;qwer&#34;).etype
        &#39;ordered&#39;
        &#34;&#34;&#34;
        if self._ø is None:
            from hosh import Identity

            self._ø = Identity(version=self.version, etype_inducer=self.etype)
        return self._ø

    @property
    def rev(self):
        &#34;&#34;&#34;
        Reversed element (warning: this is not the inverse element)

        Element with the internal cells reversed.
        This operation is its own inverse.

        This is useful wherever a unary operation is needed.
        For instance, a function can be represented as a value by its original identifier,
        and can be represented as (an applied) function by its reversed element identifier.

        Not all hoshes are digest-reversible, i.e., at the digit level, due to the intrinsic mismatch between base 64 (i.e., a power of two) representation and the group (prime) order.
        Therefore, we must resort to reversing the cells.
        As an exception, unordered elements do have (most) digits reversed as it has only one internal cell.

        Probabilistically irrelevant corner cases:
            The presence of empty cells (i.e., with zero value) might cause migration from one etype to another.
            The presence of duplicate cells (i.e., with the same value) might make the hosh reverse to itself.
            See examples below.

        Usage:

        &gt;&gt;&gt; from hosh import Hosh, groups
        &gt;&gt;&gt; h = Hosh.fromid(&#34;J5.uRTue8X4r1xu.JFkPbURVVGvTRPSFLncXdyzj&#34;).rev
        &gt;&gt;&gt; h.id
        &#39;lUz6uu1ZBCJf342R7-qKOOqWJgaf3TDHx2M.CWGT&#39;
        &gt;&gt;&gt; h.rev.rev == h
        True
        &gt;&gt;&gt; h = Hosh.fromid(&#34;ab_cabcdefabcdefabcdefabcdefabcdefabcdef&#34;)
        &gt;&gt;&gt; h.rev.id
        &#39;Hh_c7201818f76878562c52010943fe4f2a7f3b2&#39;
        &gt;&gt;&gt; h = Hosh.fromid(&#34;2_dbe78441d_____________________________&#34;)
        &gt;&gt;&gt; h.rev.id
        &#39;2_dbd14487e_____________________________&#39;

        &gt;&gt;&gt; # Limits of subgroup Z.
        &gt;&gt;&gt; Hosh.fromid(groups[40].firstp).id,  Hosh.fromid(groups[40].lastp).id
        (&#39;0_100000000_____________________________&#39;, &#39;f_8afffffff_____________________________&#39;)
        &gt;&gt;&gt; Hosh.fromid(groups[40].firstp).rev.id,  Hosh.fromid(groups[40].lastp).rev.id
        (&#39;0_100000000_____________________________&#39;, &#39;f_8afffffff_____________________________&#39;)

        &gt;&gt;&gt; # Limits of subgroup H.
        &gt;&gt;&gt; Hosh.fromid(groups[40].firstp4).id, Hosh.fromid(groups[40].lastp4).id
        (&#39;00_1000000000000000000000000000000000000&#39;, &#39;.._87c2a630003eec7dffff561b0000004aeffff&#39;)
        &gt;&gt;&gt; Hosh.fromid(groups[40].firstp4).rev.id, Hosh.fromid(groups[40].lastp4).rev.id
        (&#39;00_9ed100000015ffffffff00000000000000000&#39;, &#39;.._87c2a630003eec7dffff561b0000004aeffff&#39;)
        &gt;&gt;&gt; Hosh.fromid(groups[40].firstp4).cells, Hosh.fromid(groups[40].lastp4).cells
        ((0, 0, 0, 0, 1, 0), (0, 0, 1099511627688, 1099511627688, 1099511627688, 1099511627688))
        &gt;&gt;&gt; Hosh.fromid(groups[40].firstp4).rev.cells, Hosh.fromid(groups[40].lastp4).rev.cells
        ((0, 0, 0, 1, 0, 0), (0, 0, 1099511627688, 1099511627688, 1099511627688, 1099511627688))

        &gt;&gt;&gt; # Limits of group G.
        &gt;&gt;&gt; Hosh.fromid(groups[40].firstp6).id, Hosh.fromid(groups[40].lastp6).id
        (&#39;1000000000000000000000000000000000000000&#39;, &#39;g-8KOjCQREq2Vz8VTc30gLMd..vvX6000ov.....&#39;)
        &gt;&gt;&gt; Hosh.fromid(groups[40].firstp6).rev.id, Hosh.fromid(groups[40].lastp6).rev.id
        (&#39;00_1000000000000000000000000000000000000&#39;, &#39;g-8KOjCQREq2Vz8VTc30gLMd..vvX6000ov.....&#39;)
        &gt;&gt;&gt; Hosh.fromid(groups[40].firstp6).cells, Hosh.fromid(groups[40].lastp6).cells
        ((0, 1, 0, 0, 0, 0), (1099511627688, 1099511627688, 1099511627688, 1099511627688, 1099511627688, 1099511627688))
        &gt;&gt;&gt; Hosh.fromid(groups[40].firstp6).rev.cells, Hosh.fromid(groups[40].lastp6).rev.cells
        ((0, 0, 0, 0, 1, 0), (1099511627688, 1099511627688, 1099511627688, 1099511627688, 1099511627688, 1099511627688))

        &gt;&gt;&gt; # Near limits of group G.
        &gt;&gt;&gt; Hosh.fromn(groups[40].p4+1).id, Hosh.fromn(groups[40].p6 - 2).id
        (&#39;2000000000000000000000000000000000000000&#39;, &#39;f-8KOjCQREq2Vz8VTc30gLMd..vvX6000ov.....&#39;)
        &gt;&gt;&gt; Hosh.fromn(groups[40].p4+1).rev.id, Hosh.fromn(groups[40].p6 - 2).rev.id
        (&#39;ihdwjXvMdIj40gZQq-..5Ai0000j-....3000000&#39;, &#39;7XoPrombpt9-UXQnse30Cgud..fcZ6000kv.....&#39;)
        &gt;&gt;&gt; Hosh.fromn(groups[40].p4+1).cells, Hosh.fromn(groups[40].p6 - 2).cells
        ((0, 1, 0, 0, 0, 1), (1099511627688, 1099511627688, 1099511627688, 1099511627688, 1099511627688, 1099511627687))
        &gt;&gt;&gt; Hosh.fromn(groups[40].p4+1).rev.cells, Hosh.fromn(groups[40].p6 - 2).rev.cells
        ((1, 0, 0, 0, 1, 0), (1099511627687, 1099511627688, 1099511627688, 1099511627688, 1099511627688, 1099511627688))
        &#34;&#34;&#34;
        if self._rev is None:
            id = self.id
            if self.etype == &#34;ordered&#34;:
                self._rev = Hosh(tuple(reversed(self.cells)))
            elif self.etype == &#34;hybrid&#34;:
                self._rev = Hosh(self.cells[:2] + tuple(reversed(self.cells[2:])))
            elif self.etype == &#34;unordered&#34;:
                self._rev = Hosh.fromid(id[:4] + &#34;&#34;.join(reversed(id[4:11])) + &#34;_____________________________&#34;)
            else:  # pragma: no cover
                raise Exception(f&#34;Unexpected condition. element type: {self.etype}&#34;)
        return self._rev

    @property
    def etype(self):
        &#34;&#34;&#34;
        Type of this element

        Usage:

        &gt;&gt;&gt; from hosh import Hosh
        &gt;&gt;&gt; Hosh.fromn(5).etype
        &#39;unordered&#39;

        Returns
        -------
        &#39;ordered&#39;, &#39;hybrid&#39; or &#39;unordered&#39;
        &#34;&#34;&#34;
        if self._etype is None:
            if sum(self.cells[:5]) == 0:
                self._etype = &#34;unordered&#34;
            elif sum(self.cells[:2]) == 0:
                self._etype = &#34;hybrid&#34;
            else:
                self._etype = &#34;ordered&#34;
        return self._etype

    @property
    def etype_inducer(self):
        &#34;&#34;&#34;
        Type this element uses to coerce an element of undefined type.

        Usage:

        &gt;&gt;&gt; from hosh import ø, Hosh
        &gt;&gt;&gt; ø.etype_inducer
        &#39;ordered&#39;
        &gt;&gt;&gt; ø.h.etype_inducer
        &#39;hybrid&#39;
        &gt;&gt;&gt; ø.u.etype_inducer
        &#39;unordered&#39;
        &gt;&gt;&gt; Hosh(b&#34;12124&#34;).etype_inducer
        &#39;ordered&#39;
        &gt;&gt;&gt; Hosh(b&#34;12124&#34;, etype=&#34;hybrid&#34;).etype_inducer
        &#39;hybrid&#39;

        Returns
        -------
        &#39;ordered&#39;, &#39;hybrid&#39;, &#39;unordered&#39;
        &#34;&#34;&#34;
        if self._etype_inducer is None:
            self._etype_inducer = self.etype
        return self._etype_inducer

    @property
    def id(self):
        &#34;&#34;&#34;
        Textual representation of this element

        Returns
        -------
        Textual representation
        &#34;&#34;&#34;
        if self._id is None:
            self._id = id_fromcells(self.cells, self.digits, self.p)
        return self._id

    @classmethod
    def fromid(cls, id):
        &#34;&#34;&#34;
        Create an element from a textual id.

        Usage:

        &gt;&gt;&gt; a = Hosh.fromid(&#34;abcdefabcdefabcdefabcdefabcdefab&#34;)
        &gt;&gt;&gt; a.n
        1094566309952642687224764830259410933250743749332933330234
        &gt;&gt;&gt; a.cells
        (748932665, 516513868, 468764361, 3316970622, 2727293743, 316029245)
        &gt;&gt;&gt; a.etype
        &#39;ordered&#39;
        &gt;&gt;&gt; bid = a.id[:2] + &#34;_&#34; + a.id[3:]
        &gt;&gt;&gt; bid
        &#39;ab_defabcdefabcdefabcdefabcdefab&#39;
        &gt;&gt;&gt; b = Hosh.fromid(bid)
        &gt;&gt;&gt; b.id
        &#39;ab_defabcdefabcdefabcdefabcdefab&#39;
        &gt;&gt;&gt; b.n
        59377482839139050825606534576063885287
        &gt;&gt;&gt; b.cells
        (0, 0, 749449200, 1774140626, 3139018916, 292801225)
        &gt;&gt;&gt; b.etype
        &#39;hybrid&#39;
        &gt;&gt;&gt; Hosh.fromid(&#34;0000000000000000000000000000000000000000000000000000000000000000&#34;) == 0
        True

        Parameters
        ----------
        id

        Parameters
        ----------
        id

        Returns
        -------
        A new Hosh object
        &#34;&#34;&#34;

        if len(id) not in groups:
            raise WrongIdentifier(f&#34;Wrong identifier length: {len(id)}   id:[{id}]&#34;)
        return Hosh(cells_fromid(id, p=groups[len(id)].p), version=groups[len(id)])

    @classmethod
    def fromn(cls, n: int, version=UT40_4):
        &#34;&#34;&#34;
        Create a Hosh object representing the given int.

        Usage:

        &gt;&gt;&gt; h = Hosh.fromn(7647544756746324134134)
        &gt;&gt;&gt; h.id
        &#39;00_e49c1c505dcd0039e91000000000000000000&#39;

        Parameters
        ----------
        n
        version

        Returns
        -------
        A new Hosh object
        &#34;&#34;&#34;
        p, order = version.p, version.p6
        if n &gt; order:
            raise ElementTooHigh(f&#34;Element outside allowed range: {n} &gt;= {order}&#34;)
        return Hosh(int2cells(n, p), version=version)

    @classmethod
    def fromtensor(cls, tensor, device=None, version=UT40_4):
        &#34;&#34;&#34;
        Create a Hosh object representing the given tensor.

        Vectorized pure-Torch implementation producing 6 ints from tensor T.
        If `device` is provided and is a CUDA device, this can run on GPU.

        Usage:
        TODO: add example and generalize to other versions other than UT40_4 (need to adjust null case, multipliers, adds, and mod p)

        Parameters
        ----------
        tensor
        device
        version

        Returns
        -------
        A new Hosh object
        &#34;&#34;&#34;
        if version != &#34;UT40_4&#34;:
            raise NotImplementedError(f&#34;Unsupported version: {version}&#34;)
        import torch
        arr = tensor.reshape(-1).to(torch.int64)
        if device is not None:
            arr = arr.to(device)
        if arr.numel() == 0:
            return Hosh([0] * 6, version=version)
        # 6 distinct multipliers/adds (int64) placed on the same device as arr
        mults = torch.tensor([1315423911, 2654435761, 97531, 1000003, 1000000007, 1610612741], dtype=torch.int64, device=arr.device).unsqueeze(1)
        adds = torch.tensor([2654435761, 97531, 1000003, 1000000007, 1610612741, 1315423911], dtype=torch.int64, device=arr.device).unsqueeze(1)
        mask64 = (1 &lt;&lt; 64) - 1
        mixed = arr.unsqueeze(0) * mults
        mixed = mixed + adds
        mixed = mixed ^ (mixed &gt;&gt; 23)
        sums = mixed.sum(dim=1)
        out = []
        for s in sums:
            s_int = int(s.item()) &amp; mask64
            out.append(int(s_int % version.p))
        return Hosh(out, version=version)

    @property
    def n(self):
        &#34;&#34;&#34;
        Lexicographic rank of this eloement (according to the format adopted in internal integer cells.

        Returns
        -------
        Number
        &#34;&#34;&#34;
        if self._n is None:
            self._n = cells2int(self.cells, self.p)
        return self._n

    @property
    def sid(self):
        &#34;&#34;&#34;
        Shorter id (base-777 using up to 2 bytes utf8 per char)

        Usage:

        &gt;&gt;&gt; from hosh import ø
        &gt;&gt;&gt; (ø * b&#39;65e987978g&#39;).sid
        &#39;ȟɟìӧДɫŖāöơɟբƢŊþXÊϱՎҲģţՀɄЌ&#39;

        Returns
        -------
        Short utf-8 textual representation
        &#34;&#34;&#34;
        if self._sid is None:
            self._sid = b777enc(self.n, self.digits * 5 // 8)
        return self._sid

    @property
    def ansi(self):
        r&#34;&#34;&#34;
        Colored textual (ANSI) representation of this element

        &gt;&gt;&gt; from hosh import Hosh
        &gt;&gt;&gt; Hosh.fromid(&#34;Iaz3L67a2BQv0GifoWOjWale6LYFTGmJJ1ZPfdoP&#34;).ansi
        &#39;\x1b[38;5;229m\x1b[1m\x1b[48;5;0mI\x1b[0m\x1b[38;5;228m\x1b[1m\x1b[48;5;0ma\x1b[0m\x1b[38;5;222m\x1b[1m\x1b[48;5;0mz\x1b[0m\x1b[38;5;223m\x1b[1m\x1b[48;5;0m3\x1b[0m\x1b[38;5;228m\x1b[1m\x1b[48;5;0mL\x1b[0m\x1b[38;5;222m\x1b[1m\x1b[48;5;0m6\x1b[0m\x1b[38;5;222m\x1b[1m\x1b[48;5;0m7\x1b[0m\x1b[38;5;223m\x1b[1m\x1b[48;5;0ma\x1b[0m\x1b[38;5;228m\x1b[1m\x1b[48;5;0m2\x1b[0m\x1b[38;5;221m\x1b[1m\x1b[48;5;0mB\x1b[0m\x1b[38;5;216m\x1b[1m\x1b[48;5;0mQ\x1b[0m\x1b[38;5;186m\x1b[1m\x1b[48;5;0mv\x1b[0m\x1b[38;5;222m\x1b[1m\x1b[48;5;0m0\x1b[0m\x1b[38;5;221m\x1b[1m\x1b[48;5;0mG\x1b[0m\x1b[38;5;181m\x1b[1m\x1b[48;5;0mi\x1b[0m\x1b[38;5;194m\x1b[1m\x1b[48;5;0mf\x1b[0m\x1b[38;5;229m\x1b[1m\x1b[48;5;0mo\x1b[0m\x1b[38;5;228m\x1b[1m\x1b[48;5;0mW\x1b[0m\x1b[38;5;222m\x1b[1m\x1b[48;5;0mO\x1b[0m\x1b[38;5;223m\x1b[1m\x1b[48;5;0mj\x1b[0m\x1b[38;5;228m\x1b[1m\x1b[48;5;0mW\x1b[0m\x1b[38;5;222m\x1b[1m\x1b[48;5;0ma\x1b[0m\x1b[38;5;222m\x1b[1m\x1b[48;5;0ml\x1b[0m\x1b[38;5;223m\x1b[1m\x1b[48;5;0me\x1b[0m\x1b[38;5;228m\x1b[1m\x1b[48;5;0m6\x1b[0m\x1b[38;5;221m\x1b[1m\x1b[48;5;0mL\x1b[0m\x1b[38;5;216m\x1b[1m\x1b[48;5;0mY\x1b[0m\x1b[38;5;186m\x1b[1m\x1b[48;5;0mF\x1b[0m\x1b[38;5;222m\x1b[1m\x1b[48;5;0mT\x1b[0m\x1b[38;5;221m\x1b[1m\x1b[48;5;0mG\x1b[0m\x1b[38;5;181m\x1b[1m\x1b[48;5;0mm\x1b[0m\x1b[38;5;194m\x1b[1m\x1b[48;5;0mJ\x1b[0m\x1b[38;5;229m\x1b[1m\x1b[48;5;0mJ\x1b[0m\x1b[38;5;228m\x1b[1m\x1b[48;5;0m1\x1b[0m\x1b[38;5;222m\x1b[1m\x1b[48;5;0mZ\x1b[0m\x1b[38;5;223m\x1b[1m\x1b[48;5;0mP\x1b[0m\x1b[38;5;228m\x1b[1m\x1b[48;5;0mf\x1b[0m\x1b[38;5;222m\x1b[1m\x1b[48;5;0md\x1b[0m\x1b[38;5;222m\x1b[1m\x1b[48;5;0mo\x1b[0m\x1b[38;5;223m\x1b[1m\x1b[48;5;0mP\x1b[0m&#39;

        Returns
        -------
        Textual representation
        &#34;&#34;&#34;
        if self._ansi_light is None:
            self._ansi_light, self._ansi_dark = id2ansi(self.id)
        return self._ansi_dark if GLOBAL[&#34;dark_theme&#34;] else self._ansi_light

    @property
    def idc(self):  # pragma: no cover
        print(&#34;&#39;hosh.idc&#39; is deprecated, use &#39;hosh.ansi&#39; instead&#34;)
        return self.ansi

    @property
    def rgb(self):
        &#34;&#34;&#34;
        Colored textual (RGB) representation of this element

        &gt;&gt;&gt; from hosh import Hosh
        &gt;&gt;&gt; Hosh.fromid(&#34;Iaz3L67a2BQv0GifoWOjWale6LYFTGmJJ1ZPfdoP&#34;).rgb
        [[6, 28, 104], [255, 255, 184], [255, 255, 141], [255, 220, 155], [255, 233, 172], [255, 250, 139], [255, 218, 144], [254, 223, 150], [255, 229, 187], [255, 255, 127], [255, 206, 98], [242, 176, 123], [212, 201, 138], [237, 216, 120], [252, 198, 115], [234, 193, 174], [229, 253, 204], [255, 255, 184], [255, 255, 141], [255, 220, 155], [255, 233, 172], [255, 250, 139], [255, 218, 144], [254, 223, 150], [255, 229, 187], [255, 255, 127], [255, 206, 98], [242, 176, 123], [212, 201, 138], [237, 216, 120], [252, 198, 115], [234, 193, 174], [229, 253, 204], [255, 255, 184], [255, 255, 141], [255, 220, 155], [255, 233, 172], [255, 250, 139], [255, 218, 144], [254, 223, 150], [255, 229, 187]]
        &#34;&#34;&#34;
        if self._rgb_light is None:
            self._rgb_light, self._rgb_dark = id2rgb(self.id)
        return self._rgb_dark if GLOBAL[&#34;dark_theme&#34;] else self._rgb_light

    @property
    def html(self):
        &#34;&#34;&#34;
        HTML page containing a colored textual representation of this element

        Returns
        -------
        Textual representation
        &#34;&#34;&#34;
        return ansi2html(self.ansi)

    @property
    def shtml(self):
        &#34;&#34;&#34;Short colored html digest&#34;&#34;&#34;
        return ansi2html(self.sansi)

    @property
    def sidc(self):  # pragma: no cover
        print(&#34;&#39;hosh.sidc&#39; is deprecated, please use &#39;hosh.sansi&#39; instead&#34;)
        return self.sansi

    @property
    def sansi(self):
        &#34;&#34;&#34;
        Shorter colored id (base-777 using up to 2 bytes utf8 per char)

        Usage:

        &gt;&gt;&gt; from hosh import ø
        &gt;&gt;&gt; print((ø * b&#39;65e987978g&#39;).sansi)
        \x1b[38;5;156m\x1b[1m\x1b[48;5;0mȟ\x1b[0m\x1b[38;5;155m\x1b[1m\x1b[48;5;0mɟ\x1b[0m\x1b[38;5;185m\x1b[1m\x1b[48;5;0mì\x1b[0m\x1b[38;5;113m\x1b[1m\x1b[48;5;0mӧ\x1b[0m\x1b[38;5;119m\x1b[1m\x1b[48;5;0mД\x1b[0m\x1b[38;5;185m\x1b[1m\x1b[48;5;0mɫ\x1b[0m\x1b[38;5;113m\x1b[1m\x1b[48;5;0mŖ\x1b[0m\x1b[38;5;119m\x1b[1m\x1b[48;5;0mā\x1b[0m\x1b[38;5;149m\x1b[1m\x1b[48;5;0mö\x1b[0m\x1b[38;5;113m\x1b[1m\x1b[48;5;0mơ\x1b[0m\x1b[38;5;83m\x1b[1m\x1b[48;5;0mɟ\x1b[0m\x1b[38;5;155m\x1b[1m\x1b[48;5;0mբ\x1b[0m\x1b[38;5;149m\x1b[1m\x1b[48;5;0mƢ\x1b[0m\x1b[38;5;119m\x1b[1m\x1b[48;5;0mŊ\x1b[0m\x1b[38;5;185m\x1b[1m\x1b[48;5;0mþ\x1b[0m\x1b[38;5;119m\x1b[1m\x1b[48;5;0mX\x1b[0m\x1b[38;5;156m\x1b[1m\x1b[48;5;0mÊ\x1b[0m\x1b[38;5;155m\x1b[1m\x1b[48;5;0mϱ\x1b[0m\x1b[38;5;185m\x1b[1m\x1b[48;5;0mՎ\x1b[0m\x1b[38;5;113m\x1b[1m\x1b[48;5;0mҲ\x1b[0m\x1b[38;5;119m\x1b[1m\x1b[48;5;0mģ\x1b[0m\x1b[38;5;185m\x1b[1m\x1b[48;5;0mţ\x1b[0m\x1b[38;5;113m\x1b[1m\x1b[48;5;0mՀ\x1b[0m\x1b[38;5;119m\x1b[1m\x1b[48;5;0mɄ\x1b[0m\x1b[38;5;149m\x1b[1m\x1b[48;5;0mЌ\x1b[0m

        Returns
        -------
        Short utf-8 colored textual representation
        &#34;&#34;&#34;
        if self._sansi_light is None:
            self._sansi_light, self._sansi_dark = id2ansi(self.sid)
        return self._sansi_dark if GLOBAL[&#34;dark_theme&#34;] else self._sansi_light

    def __repr__(self):
        if GLOBAL[&#34;format&#34;] == BW:
            return self.sid if GLOBAL[&#34;short&#34;] else self.id
        elif GLOBAL[&#34;format&#34;] == ANSI:
            return self.sansi if GLOBAL[&#34;short&#34;] else self.ansi
        elif GLOBAL[&#34;format&#34;] == HTML:
            return self.shtml if GLOBAL[&#34;short&#34;] else self.html
        elif callable(GLOBAL[&#34;format&#34;]):  # pragma: no cover
            return GLOBAL[&#34;format&#34;](self)
        else:  # pragma: no cover
            raise Exception(f&#34;Unknown format: {GLOBAL[&#39;format&#39;]}&#34;)

    def __xor__(self, other: int):
        if other == 1:
            return self
        return Hosh(cellspow(self.cells, other, self.p), version=self.version)

    def __mul__(self, other: Union[&#34;Hosh&#34;, str, bytes, int]):
        if (other := self.convert(other)) is NotImplemented:  # pragma: no cover
            return NotImplemented
        return Hosh(cellsmul(self.cells, other.cells, self.p), version=self.version)

    def __rmul__(self, other: Union[&#34;Hosh&#34;, str, bytes, int]):
        &#34;&#34;&#34;
        &gt;&gt;&gt; from hosh import ø
        &gt;&gt;&gt; (ø * b&#34;13dfv34y4&#34; )* b&#34;434vbfrdg&#34; == b&#34;13dfv34y4&#34; * (ø * b&#34;434vbfrdg&#34;)
        True

        Parameters
        ----------
        other

        Returns
        -------

        &#34;&#34;&#34;
        if (other := self.convert(other)) is NotImplemented:  # pragma: no cover
            return NotImplemented
        return Hosh(cellsmul(other.cells, self.cells, self.p), version=self.version)

    def __rpow__(self, other):
        &#34;&#34;&#34;
        &gt;&gt;&gt; from hosh import ø
        &gt;&gt;&gt; (ø * b&#34;13dfv34y4&#34;) ** b&#34;434vbfrdg&#34; == b&#34;13dfv34y4&#34; ** (ø * b&#34;434vbfrdg&#34;)
        True

        Parameters
        ----------
        other

        Returns
        -------

        &#34;&#34;&#34;
        if (other := self.convert(other)) is NotImplemented:  # pragma: no cover
            return NotImplemented
        return +(+other * +self)

    def __pow__(self, power, modulo=None):
        if (power := self.convert(power)) is NotImplemented:  # pragma: no cover
            return NotImplemented
        return +(+self * +power)

    def __rfloordiv__(self, other):
        &#34;&#34;&#34;
        &gt;&gt;&gt; from hosh import ø
        &gt;&gt;&gt; (ø * b&#34;13dfv34y4&#34;) // b&#34;434vbfrdg&#34; == b&#34;13dfv34y4&#34; // (ø * b&#34;434vbfrdg&#34;)
        True

        Parameters
        ----------
        other

        Returns
        -------

        &#34;&#34;&#34;
        if (other := self.convert(other)) is NotImplemented:  # pragma: no cover
            return NotImplemented
        return +(+other / +self)

    def __floordiv__(self, other):
        &#34;&#34;&#34;Lift&#34;&#34;&#34;
        if (other := self.convert(other)) is NotImplemented:  # pragma: no cover
            return NotImplemented
        return +(+self / +other)

    def __neg__(self):
        return Hosh(cellsinv(self.cells, self.p, additive=True), version=self.version)

    def __pos__(self):
        &#34;&#34;&#34;Change disposition of element-matrix cells in a way that even hybrid ids will not commute.
        ps. Semantics of +hosh are completely unrelated from -hosh as -hosh creates the inverse additive element.

        Switch positions of cells a2 and a5. This operation is its own inverse.

        Cells are represented as a tuple in the format: (a5, a4, a3, a2, a1, a0)
        Cells are represented as a matrix in the format:
        1 a4 a1 a0
        0  1 a2 a3
        0  0  1 a5
        0  0  0  1

        &#34;&#34;&#34;
        cells = self.cells
        return Hosh((cells[3], cells[1], cells[2], cells[0], cells[4], cells[5]), version=self.version)

    def __invert__(self):
        return Hosh(cellsinv(self.cells, self.p), version=self.version)

    def __rtruediv__(self, other):
        &#34;&#34;&#34;
        &gt;&gt;&gt; from hosh import ø
        &gt;&gt;&gt; (ø * b&#34;13dfv34y4&#34;) / b&#34;434vbfrdg&#34; == b&#34;13dfv34y4&#34; / (ø * b&#34;434vbfrdg&#34;)
        True

        Parameters
        ----------
        other

        Returns
        -------

        &#34;&#34;&#34;
        if (other := self.convert(other)) is NotImplemented:  # pragma: no cover
            return NotImplemented
        return Hosh(cellsmul(other.cells, cellsinv(self.cells, self.p), self.p), version=self.version)

    def __truediv__(self, other):
        if (other := self.convert(other)) is NotImplemented:  # pragma: no cover
            return NotImplemented
        return Hosh(cellsmul(self.cells, cellsinv(other.cells, self.p), self.p), version=self.version)

    def __add__(self, other):
        &#34;&#34;&#34;Matrix addition modulo p, keeping unidiagonal&#34;&#34;&#34;
        if (other := self.convert(other)) is NotImplemented:  # pragma: no cover
            return NotImplemented
        cells = tuple(map(lambda x, y: (x + y) % self.p, self.cells, other.cells))
        return Hosh(cells, version=self.version)

    def __sub__(self, other):  # TODO: check if a - b  here is different from a + (-b) ?
        &#34;&#34;&#34;Matrix subtraction modulo p, keeping unidiagonal&#34;&#34;&#34;
        if (other := self.convert(other)) is NotImplemented:  # pragma: no cover
            return NotImplemented
        cells = tuple(map(lambda x, y: (x - y) % self.p, self.cells, other.cells))
        return Hosh(cells, version=self.version)
        # REMINDER: the chosen implementation differs from the alternative bellow!
        # return Hosh.fromn((self.n + self.convert(other).n) % self.order, self.version)

    def __str__(self):
        return self.sid if GLOBAL[&#34;short&#34;] else self.id

    def __eq__(self, other):
        if (other := self.convert(other)) is NotImplemented:  # pragma: no cover
            return NotImplemented
        return self.n == other.n

    def __ne__(self, other):
        if (other := self.convert(other)) is NotImplemented:  # pragma: no cover
            return NotImplemented
        return self.n != other.n

    def show(self, colored=True):
        &#34;&#34;&#34;
        Usage:

        &gt;&gt;&gt; Hosh(b&#34;asdf86fasd&#34;).show(colored=False)
        voh8t1KrYmzCqpyrUO9.5QbGdouoZsnExarMSa34
        &#34;&#34;&#34;
        return print(self.ansi if colored else self.id)

    def short(self, colored=True):
        &#34;&#34;&#34;
        Usage:

        &gt;&gt;&gt; Hosh(b&#34;asdf86fasd&#34;).short(colored=False)
        lϊӑơӫǯÃϺŮϳȐŁЬĽҪƉǏԛȪƜfÞӠȕՇ
        &#34;&#34;&#34;
        return print(self.sansi if colored else self.sid)

    def __hash__(self):
        return self.n % maxsize

    def convert(self, other):
        &#34;&#34;&#34;
        Usage:

        &gt;&gt;&gt; from hosh import ø
        &gt;&gt;&gt; ø.convert([0,0,0,0,0,0]).id
        &#39;0000000000000000000000000000000000000000&#39;

        &gt;&gt;&gt; from hosh import Hosh
        &gt;&gt;&gt; ø.convert(0).id
        &#39;0000000000000000000000000000000000000000&#39;

        Parameters
        ----------
        other

        Returns
        -------

        &#34;&#34;&#34;
        if isinstance(other, str):
            other = Hosh.fromid(other)
        elif isinstance(other, bytes):
            other = Hosh(other, etype=self.etype_inducer, version=self.version)
        elif isinstance(other, int):
            other = Hosh.fromn(other, version=self.version)
        elif isinstance(other, (tuple | list)):
            other = Hosh(other, version=self.version)
        elif not isinstance(other, Hosh):
            return NotImplemented
        if self.version != other.version:
            raise WrongVersion(f&#34;Incompatible operands: {self.version} != {other.version}&#34;)
        return other

    def root(self, k):
        &#34;&#34;&#34;
        &gt;&gt;&gt; a = Hosh(b&#34;a&#34;)
        &gt;&gt;&gt; for i in range(1, 5):
        ...     r = a.root(i)
        ...     r^i == a
        True
        True
        True
        True
        &#34;&#34;&#34;
        if k == 1:
            return self
        return Hosh(cellsroot(self.cells, k, self.p), version=self.version)

    def power_component(self, i, n):
        &#34;&#34;&#34;Elements corresponding to `n` components of &#34;multiplicative decomposition&#34; such that
        `x  =  x1 * x2 * x3 * ... * xn  =  x * x² * x³ * ... * x^n`

        Not very useful as the resulting elements commute among themselves.
        This happens because they are all powers of x, making up just a sequence of `x`s .

        Parameters
        ==========
        i
            Desired component index
        n
            Desired total number of components

        Returns
        =======
            Hosh (component)

        &gt;&gt;&gt; a = Hosh(b&#34;a&#34;)
        &gt;&gt;&gt; a.power_component(0, 1) == a
        True
        &gt;&gt;&gt; a.power_component(0, 2) * a.power_component(1, 2) == a
        True
        &gt;&gt;&gt; a.power_component(0, 3) * a.power_component(1, 3) * a.power_component(2, 3) == a
        True
        &gt;&gt;&gt; a.power_component(2, 3) * a.power_component(1, 3) * a.power_component(0, 3) == a
        True
        &#34;&#34;&#34;
        if i &gt;= n:  # pragma: no cover
            raise Exception(f&#34;Hosh component should be defined by &#39;index&#39; ({i}) &lt; &#39;#components&#39; ({n})&#34;)
        if n == 1:
            return self
        exp = n * (n + 1) // 2
        r = self.root(exp)
        return r ^ (i + 1)

    def bad_additive_components(self, n):
        &#34;&#34;&#34;
        Return the `n` additive components for `x` such that `x = x1 + x2 + ... + xn`

        `xn` fills the gap left by the other components remainder.
        We do not recommend this &#34;decomposition&#34; as it always generates different ids for the same subvalue.
        For instance,
            if a list `[value1, value2, value3]` induces ids `a`, `b`, and `any`,
             another list `[value1, value2, ...]` necessarily induces `c` and `d` as first two ids such that `a != c` and `b != d`.

        Parameters
        ==========
        n
            Desired total number of components

        Returns
        =======
            Generator of hoshes

        &gt;&gt;&gt; from functools import reduce
        &gt;&gt;&gt; import operator
        &gt;&gt;&gt; reduce(operator.add, Hosh(b&#34;x&#34;).bad_additive_components(5)) == Hosh(b&#34;x&#34;)
        True
        &#34;&#34;&#34;
        den = n * (n + 1) // 2
        p = self.p

        def fac(x):
            parc, rem = divmod(x + p, den)
            lst = [i * parc for i in range(1, n + 1)]
            lst[-1] += rem
            return [l % p for l in lst]

        return (Hosh(tuple(x), version=self.version) for x in zip(*(fac(c) for c in self.cells)))

    def bad_additive_component(self, i, n):
        &#34;&#34;&#34;
        Return the `i`-th additive component for `x` such that `x = x1 + x2 + ... + xn`

        See `bad_additive_components` for more details.

        &gt;&gt;&gt; from functools import reduce
        &gt;&gt;&gt; import operator
        &gt;&gt;&gt; list(Hosh(b&#34;x&#34;).bad_additive_components(2))[0] == Hosh(b&#34;x&#34;).bad_additive_component(0, 2)
        True
        &gt;&gt;&gt; list(Hosh(b&#34;x&#34;).bad_additive_components(2))[1] == Hosh(b&#34;x&#34;).bad_additive_component(1, 2)
        True
        &gt;&gt;&gt; list(Hosh(b&#34;x&#34;).bad_additive_components(3))[0] == Hosh(b&#34;x&#34;).bad_additive_component(0, 3)
        True
        &gt;&gt;&gt; list(Hosh(b&#34;x&#34;).bad_additive_components(3))[1] == Hosh(b&#34;x&#34;).bad_additive_component(1, 3)
        True
        &gt;&gt;&gt; list(Hosh(b&#34;x&#34;).bad_additive_components(3))[2] == Hosh(b&#34;x&#34;).bad_additive_component(2, 3)
        True
        &gt;&gt;&gt; list(Hosh(b&#34;x&#34;).bad_additive_components(5))[0] == Hosh(b&#34;x&#34;).bad_additive_component(0, 5)
        True
        &gt;&gt;&gt; list(Hosh(b&#34;x&#34;).bad_additive_components(5))[1] == Hosh(b&#34;x&#34;).bad_additive_component(1, 5)
        True
        &gt;&gt;&gt; list(Hosh(b&#34;x&#34;).bad_additive_components(5))[2] == Hosh(b&#34;x&#34;).bad_additive_component(2, 5)
        True
        &gt;&gt;&gt; list(Hosh(b&#34;x&#34;).bad_additive_components(5))[4] == Hosh(b&#34;x&#34;).bad_additive_component(4, 5)
        True
        &gt;&gt;&gt; list(Hosh(b&#34;x&#34;).bad_additive_components(7))[0] == Hosh(b&#34;x&#34;).bad_additive_component(0, 7)
        True
        &gt;&gt;&gt; list(Hosh(b&#34;x&#34;).bad_additive_components(7))[1] == Hosh(b&#34;x&#34;).bad_additive_component(1, 7)
        True
        &gt;&gt;&gt; list(Hosh(b&#34;x&#34;).bad_additive_components(7))[2] == Hosh(b&#34;x&#34;).bad_additive_component(2, 7)
        True
        &gt;&gt;&gt; list(Hosh(b&#34;x&#34;).bad_additive_components(7))[4] == Hosh(b&#34;x&#34;).bad_additive_component(4, 7)
        True
        &#34;&#34;&#34;
        den = n * (n + 1) // 2
        p = self.p
        i += 1
        toggle = 1 if i == n else 0

        def fac(x):
            parc, rem = divmod(x + p, den)
            return (i * parc + toggle * rem) % p

        return Hosh(tuple(fac(c) for c in self.cells), version=self.version)

    def components(self, start, stop, n, additive=False):
        r&#34;&#34;&#34;
        Pseudo&#34;decomposition&#34; based on the hosh of the current id concatenated as bytes to a given component index

        Perform a multiplicative decomposition by default.

        Syntax:
            Hosh(b&#34;blob&#34;).components(i, m, n)   # Takes a slice of elements.
            Hosh(b&#34;blob&#34;)[i:m, n]               # Takes a slice of elements.
            Hosh(b&#34;blob&#34;)[i, n]                 # Takes element `i` out of `n` components.
            Hosh(b&#34;blob&#34;)[:n, n]                # All `n` elements.
        Warning:
            Hosh(b&#34;blob&#34;)[-1]                   # Reverse element. Not to be confused with inverse element.


        The components are arbitrarily internally defined group elements based on current id as hashed bytes:
        Hosh(id+&#34;-1&#34;), Hosh(id+&#34;-2&#34;), ..., Hosh(id+&#34;-n&#34;)

        The last element (xn) is the exception as it makes the product x1 * x2 * ... * xn match x:
        x1      = id+&#34;-1&#34; * x
         ...
        xn-1    = id+&#34;-n-1&#34; * x
        xn      = (id+&#34;-1&#34; * x * ... * id+&#34;-n-1&#34;)-¹

        Parameters
        ==========
        start
            Start of a slice
        stop
            Stop of a slice
        n
            Desired total number of components
        additive
            Set up an additive decomposition

        Returns
        =======
            List if hoshes

        &gt;&gt;&gt; from hosh import Hosh
        &gt;&gt;&gt; a = Hosh(b&#34;a&#34;)
        &gt;&gt;&gt; a[-1].rev == a
        True
        &gt;&gt;&gt; a[0, 1] == a
        True
        &gt;&gt;&gt; a[0:, 1][0] == a
        True
        &gt;&gt;&gt; a[:1, 1][0] == a
        True
        &gt;&gt;&gt; a[0:1, 1][0] == a
        True
        &gt;&gt;&gt; from operator import mul
        &gt;&gt;&gt; reduce(mul, a[:, 3]) == a
        True
        &gt;&gt;&gt; [x.id for x in a[:, 3]]
        [&#39;Bd6Axil5pFSp15HUBz8eCujvu3gBsEk6XMpRsMNo&#39;, &#39;32MloLPcivDbbPMCJn1RBY31aNZ6z-Dqnt4vQhot&#39;, &#39;la3xnZmlhn3lFBAnvWw-UWAvK.2hk-QqUNFYAs3e&#39;]
        &gt;&gt;&gt; a[:, 3][0] * a[:, 3][1] * a[:, 3][2] == a
        True
        &gt;&gt;&gt; a[0, 3] * a[1, 3] * a[2, 3] == a
        True
        &gt;&gt;&gt; a.id
        &#39;cIXBKPediDiOKabeZ6SthD04rnzaquNXaAEhSud4&#39;
        &gt;&gt;&gt; from operator import add, mul
        &gt;&gt;&gt; from functools import reduce
        &gt;&gt;&gt; print(&#34;\n&#34;.join(x.id for x in a.components(0, 7, 7)))
        Bd6Axil5pFSp15HUBz8eCujvu3gBsEk6XMpRsMNo
        32MloLPcivDbbPMCJn1RBY31aNZ6z-Dqnt4vQhot
        Y2JlyuF8.KJc0DvvcIivLA5uLYloF7HN9ovO14Sq
        6.F-NB-G4vBXs7evbBImex9x3foNi85Ca7wDb1c3
        tZmUsjVcZAGTajUOzsSNrr7a7BQVNSiA6xaiPEYf
        iCLMdAlduXvUtK1.awng0D0YP49kV8Cit7OLXyab
        BA6UvITsIN822llT9eErc1R0rmf.ARbc0adwEbWk
        &gt;&gt;&gt; reduce(mul, a.components(0, 2, 7)) * reduce(mul, a.components(2, 3, 7)) * reduce(mul, a.components(3, 7, 7)) == a
        True
        &gt;&gt;&gt; reduce(mul, a.components(0, 7, 7)) == a
        True

        &gt;&gt;&gt; print(&#34;\n&#34;.join(x.id for x in a.components(0, 7, 7, additive=True)))
        Bd6Axil5pFSp15HUBz8eCujvu3gBsEk6XMpRsMNo
        32MloLPcivDbbPMCJn1RBY31aNZ6z-Dqnt4vQhot
        Y2JlyuF8.KJc0DvvcIivLA5uLYloF7HN9ovO14Sq
        6.F-NB-G4vBXs7evbBImex9x3foNi85Ca7wDb1c3
        tZmUsjVcZAGTajUOzsSNrr7a7BQVNSiA6xaiPEYf
        iCLMdAlduXvUtK1.awng0D0YP49kV8Cit7OLXyab
        7jJmsfrPpa2CeeYCAiByF3HW2J9.ARbc0adwEbWk
        &gt;&gt;&gt; reduce(add, a.components(0, 2, 7, additive=True)) + reduce(add, a.components(2, 3, 7, additive=True)) + reduce(add, a.components(3, 7, 7, additive=True)) == a
        True
        &gt;&gt;&gt; reduce(add, a.components(0, 7, 7, additive=True)) == a
        True
        &#34;&#34;&#34;
        if stop &gt; n:  # pragma: no cover
            raise Exception(f&#34;Wrong value:   stop=`{stop}`  &gt;=  n=`{n}`&#34;)
        acc = self.ø
        operator = add if additive else mul
        for i in range(0, stop):
            if stop == n and i == stop - 1:
                break
            if (t := (i, n, additive)) not in self._composition_memo:
                self._composition_memo[t] = Hosh(f&#34;{self.id}-{i}&#34;.encode(), version=self.version)
                if len(self._composition_memo) &gt; self.components_cache_size:  # pragma: no cover
                    first = next(iter(self._composition_memo))
                    del self._composition_memo[first]
            h = self._composition_memo[t]
            acc = operator(acc, h)
            if i &gt;= start:
                yield h
        if stop == n:
            inv = Hosh(cellsinv(acc.cells, self.p, additive), version=self.version)
            last = operator(inv, self)
            yield last

    def __getitem__(self, item: Union[int, tuple]):
        &#34;&#34;&#34;
        Reverse element:    Hosh(b&#34;blob&#34;)[-1]
        &#34;&#34;&#34;
        if item == -1:
            return self.rev
        if not isinstance(item, tuple) or len(item) != 2:  # pragma: no cover
            raise Exception(&#34;Wrong syntax, tuple or `-1` expected: hosh[-1] or hosh[i, n] or hosh[l:m, n]&#34;)
        slc, n = item
        if n &lt;= 0:  # pragma: no cover
            raise Exception(f&#34;Wrong value: n={n}  &lt;=  0&#34;)

        if isinstance(idx := slc, int):
            if idx &lt; n - 1:
                return Hosh(f&#34;{self.id}-{idx}&#34;.encode())
            if n == 1:
                return self
            if idx == n - 1:
                return list(self.components(0, n, n))[idx]
            raise Exception(f&#34;Wrong value: i={slc}  &gt;  n={n}&#34;)  # pragma: no cover

        if not isinstance(slc, slice) or slc.step is not None:  # pragma: no cover
            raise Exception(f&#34;Wrong syntax. Simple slice or index expected as first tuple item, not `{slc}`: hosh[i, n] or hosh[l:m, n]&#34;)

        if (start := slc.start) is None:
            start = 0
        if (stop := slc.stop) is None:
            stop = n

        if start &gt; n or start &lt; 0:  # pragma: no cover
            raise Exception(f&#34;Wrong values, expected: 0  &lt;=  i={start}  &lt;=  n={n}&#34;)
        if n == 1:
            return [self]
        return list(self.components(start, stop, n))

    @property
    def bits(self):
        &#34;&#34;&#34;
        &gt;&gt;&gt; from hosh import Hosh, groups
        &gt;&gt;&gt; Hosh(b&#34;asd&#34;).bits
        &#39;000110111101001001111010010101011100011010000011101010100000000001101101111101100111110100001011001001111001110110101101100110000000011111000110100100110011110010101110100011111101100010010111100111010101010011001110000001000100001101001111&#39;
        &gt;&gt;&gt; bits = Hosh.fromn(groups[40].p6 - 1).bits  # Max number.
        &gt;&gt;&gt; bits
        &#39;111111111111111111111111111111011111011000000000000000000000000110111011011111101111111111111111001101110000101001110100000000000011001100111000100101011110111011111001000010011000001000000100101101100110010011110110001000101011101110110000&#39;
        &gt;&gt;&gt; int(bits, 2) == groups[40].p6 - 1
        True
        &#34;&#34;&#34;
        if self._bits is None:
            self._bits = &#39;{:b}&#39;.format(self.n).rjust(self.digits * 6, &#34;0&#34;)
        return self._bits

    def __reduce__(self):
        return self.fromid, (self.id,)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="hosh.hosh_.Hosh"><code class="flex name class">
<span>class <span class="ident">Hosh</span></span>
<span>(</span><span>content, etype='default:ordered', version=Group(p=1099511627689, p4=1461501636868331575725436266114840805196834679841, p6=1766847063939562670646036165286872353986524172769430561878277294118845361, digits=40, bytes=30, firstp='0_100000000_____________________________', lastp='f_8afffffff_____________________________', firstp4='00_1000000000000000000000000000000000000', lastp4='.._87c2a630003eec7dffff561b0000004aeffff', firstp6='1000000000000000000000000000000000000000', lastp6='g-8KOjCQREq2Vz8VTc30gLMd..vvX6000ov.....'))</span>
</code></dt>
<dd>
<div class="desc"><p>Operable hash.</p>
<p>Generate a Hosh object from a binary content or a list of 6 ints.</p>
<p>Usage:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from hosh import Hosh
&gt;&gt;&gt; a = Hosh(b&quot;lots of data&quot;)
&gt;&gt;&gt; b = Hosh(b&quot;lots of data 2&quot;)
&gt;&gt;&gt; a.id
'.-0byLo.CdKjKN6RFTYqBIy30OST3oLyjYPf.6p8'
&gt;&gt;&gt; b.id
'SXBse5Ie-yUCa7h7gZiHXGkkKdispqxlc4FnCYit'
&gt;&gt;&gt; (a * b).id
'ALiaB9XPu.MoIwwoTPYrxqkGfVpktOgUv0tDB3IB'
&gt;&gt;&gt; (b * a).id
'gr9psTs5dYGrCCdgWMAPWM4dDDzktOgUv0tDB3IB'
&gt;&gt;&gt; a * b * ~b == a
True
&gt;&gt;&gt; c = Hosh(b&quot;lots of data 3&quot;)
&gt;&gt;&gt; (a * b) * c == a * (b * c)
True
&gt;&gt;&gt; e = Hosh(b&quot;lots of data 4&quot;)
&gt;&gt;&gt; f = Hosh(b&quot;lots of data 5&quot;)
&gt;&gt;&gt; e * f != f * e
True
&gt;&gt;&gt; a * b != b * a
True
&gt;&gt;&gt; x = Hosh(b&quot;lots of data 6&quot;, &quot;hybrid&quot;)
&gt;&gt;&gt; y = Hosh(b&quot;lots of data 7&quot;, &quot;hybrid&quot;)
&gt;&gt;&gt; z = Hosh(b&quot;lots of data 8&quot;, &quot;unordered&quot;)
&gt;&gt;&gt; x * y == y * x
True
&gt;&gt;&gt; x * a != a * x
True
&gt;&gt;&gt; x * z == z * x
True
&gt;&gt;&gt; a * z == z * a
True
&gt;&gt;&gt; from hosh import ø
&gt;&gt;&gt; print(ø)  # Handy syntax using ø for identity.
0000000000000000000000000000000000000000
&gt;&gt;&gt; print(ø * &quot;7ysdf98ys34hg543hdf98ysdf98ysdfysdf98ysd&quot;)  # str, bytes or int are converted as id, blob or element rank.
7ysdf98ys34hg543hdf98ysdf98ysdfysdf98ysd
&gt;&gt;&gt; print(ø * &quot;7ysdf98ysdf98ysdf98ysdfysdf98ysdasddsa32&quot; * &quot;6gdsf76dfqwe123de8gaf87gaf87gaf87agdfa78&quot;)
94UrdYKjCGQWdd5P.W4xvFJgc9hZpIHlhytqHkaa
&gt;&gt;&gt; h = ø.u * b&quot;sdff&quot;
&gt;&gt;&gt; print(h)
f_9e1a267c8_____________________________
&gt;&gt;&gt; x.id, (+x).id  # Making an ordered x.
('ZN_60eec3e6c7b68087329e16b581401a6bb2b1f', '6BDj3b7Mmj7n-6B8XYaP3akO7400s9FlG4AtcHTp')
&gt;&gt;&gt; +x * y != y * +x
True
&gt;&gt;&gt; ++x == x
True
&gt;&gt;&gt; x ** y == +(+x * +y)  # a ** b is a shortcut for +(+a * +b)
True
&gt;&gt;&gt; x ** y != y ** x
True
&gt;&gt;&gt; (x ** b&quot;1&quot;) * (y ** b&quot;2&quot;) != (x ** b&quot;2&quot;) * (y ** b&quot;1&quot;)
True
&gt;&gt;&gt; (x ** b&quot;1&quot;) * (y ** b&quot;2&quot;) == (y ** b&quot;2&quot;) * (x ** b&quot;1&quot;)
True
&gt;&gt;&gt; (x ** y) // y == x
True
&gt;&gt;&gt; f + e - x == ø - x + e + f  # Alternative (always unordered, i.e., form an Abelian group) operation
True
&gt;&gt;&gt; import pickle
&gt;&gt;&gt; d = pickle.dumps(x, protocol=5)
&gt;&gt;&gt; d
b'\x80\x05\x95j\x00\x00\x00\x00\x00\x00\x00\x8c\x08builtins\x94\x8c\x07getattr\x94\x93\x94\x8c\nhosh.hosh_\x94\x8c\x04Hosh\x94\x93\x94\x8c\x06fromid\x94\x86\x94R\x94\x8c(ZN_60eec3e6c7b68087329e16b581401a6bb2b1f\x94\x85\x94R\x94.'
&gt;&gt;&gt; pickle.loads(d) == x
True
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>content</code></strong></dt>
<dd>Binary content to be hashed, or a tuple of six integers</dd>
<dt><strong><code>etype</code></strong></dt>
<dd>ordered, hybrid, unordered
According to the subset of the desired element: Z, H\Z or G\H</dd>
<dt><strong><code>version</code></strong></dt>
<dd>Group namedtuple: changes the number of digits and robustness against collisions
UT32_4 is enough for most usages. It accepts more than 4 billion repetitions of the same operation in a row.
UT64_4 provides unspeakable limits for operations, please see scientific paper for details.
UT40_4 is recommended and default, since it is the most compatible with other systems (git, SHA-1, etc)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Hosh:
    r&#34;&#34;&#34;
    Operable hash.

    Generate a Hosh object from a binary content or a list of 6 ints.

    Usage:

    &gt;&gt;&gt; from hosh import Hosh
    &gt;&gt;&gt; a = Hosh(b&#34;lots of data&#34;)
    &gt;&gt;&gt; b = Hosh(b&#34;lots of data 2&#34;)
    &gt;&gt;&gt; a.id
    &#39;.-0byLo.CdKjKN6RFTYqBIy30OST3oLyjYPf.6p8&#39;
    &gt;&gt;&gt; b.id
    &#39;SXBse5Ie-yUCa7h7gZiHXGkkKdispqxlc4FnCYit&#39;
    &gt;&gt;&gt; (a * b).id
    &#39;ALiaB9XPu.MoIwwoTPYrxqkGfVpktOgUv0tDB3IB&#39;
    &gt;&gt;&gt; (b * a).id
    &#39;gr9psTs5dYGrCCdgWMAPWM4dDDzktOgUv0tDB3IB&#39;
    &gt;&gt;&gt; a * b * ~b == a
    True
    &gt;&gt;&gt; c = Hosh(b&#34;lots of data 3&#34;)
    &gt;&gt;&gt; (a * b) * c == a * (b * c)
    True
    &gt;&gt;&gt; e = Hosh(b&#34;lots of data 4&#34;)
    &gt;&gt;&gt; f = Hosh(b&#34;lots of data 5&#34;)
    &gt;&gt;&gt; e * f != f * e
    True
    &gt;&gt;&gt; a * b != b * a
    True
    &gt;&gt;&gt; x = Hosh(b&#34;lots of data 6&#34;, &#34;hybrid&#34;)
    &gt;&gt;&gt; y = Hosh(b&#34;lots of data 7&#34;, &#34;hybrid&#34;)
    &gt;&gt;&gt; z = Hosh(b&#34;lots of data 8&#34;, &#34;unordered&#34;)
    &gt;&gt;&gt; x * y == y * x
    True
    &gt;&gt;&gt; x * a != a * x
    True
    &gt;&gt;&gt; x * z == z * x
    True
    &gt;&gt;&gt; a * z == z * a
    True
    &gt;&gt;&gt; from hosh import ø
    &gt;&gt;&gt; print(ø)  # Handy syntax using ø for identity.
    0000000000000000000000000000000000000000
    &gt;&gt;&gt; print(ø * &#34;7ysdf98ys34hg543hdf98ysdf98ysdfysdf98ysd&#34;)  # str, bytes or int are converted as id, blob or element rank.
    7ysdf98ys34hg543hdf98ysdf98ysdfysdf98ysd
    &gt;&gt;&gt; print(ø * &#34;7ysdf98ysdf98ysdf98ysdfysdf98ysdasddsa32&#34; * &#34;6gdsf76dfqwe123de8gaf87gaf87gaf87agdfa78&#34;)
    94UrdYKjCGQWdd5P.W4xvFJgc9hZpIHlhytqHkaa
    &gt;&gt;&gt; h = ø.u * b&#34;sdff&#34;
    &gt;&gt;&gt; print(h)
    f_9e1a267c8_____________________________
    &gt;&gt;&gt; x.id, (+x).id  # Making an ordered x.
    (&#39;ZN_60eec3e6c7b68087329e16b581401a6bb2b1f&#39;, &#39;6BDj3b7Mmj7n-6B8XYaP3akO7400s9FlG4AtcHTp&#39;)
    &gt;&gt;&gt; +x * y != y * +x
    True
    &gt;&gt;&gt; ++x == x
    True
    &gt;&gt;&gt; x ** y == +(+x * +y)  # a ** b is a shortcut for +(+a * +b)
    True
    &gt;&gt;&gt; x ** y != y ** x
    True
    &gt;&gt;&gt; (x ** b&#34;1&#34;) * (y ** b&#34;2&#34;) != (x ** b&#34;2&#34;) * (y ** b&#34;1&#34;)
    True
    &gt;&gt;&gt; (x ** b&#34;1&#34;) * (y ** b&#34;2&#34;) == (y ** b&#34;2&#34;) * (x ** b&#34;1&#34;)
    True
    &gt;&gt;&gt; (x ** y) // y == x
    True
    &gt;&gt;&gt; f + e - x == ø - x + e + f  # Alternative (always unordered, i.e., form an Abelian group) operation
    True
    &gt;&gt;&gt; import pickle
    &gt;&gt;&gt; d = pickle.dumps(x, protocol=5)
    &gt;&gt;&gt; d
    b&#39;\x80\x05\x95j\x00\x00\x00\x00\x00\x00\x00\x8c\x08builtins\x94\x8c\x07getattr\x94\x93\x94\x8c\nhosh.hosh_\x94\x8c\x04Hosh\x94\x93\x94\x8c\x06fromid\x94\x86\x94R\x94\x8c(ZN_60eec3e6c7b68087329e16b581401a6bb2b1f\x94\x85\x94R\x94.&#39;
    &gt;&gt;&gt; pickle.loads(d) == x
    True

    Parameters
    ----------
    content
        Binary content to be hashed, or a tuple of six integers
    etype
        ordered, hybrid, unordered
        According to the subset of the desired element: Z, H\\Z or G\\H
    version
        Group namedtuple: changes the number of digits and robustness against collisions
        UT32_4 is enough for most usages. It accepts more than 4 billion repetitions of the same operation in a row.
        UT64_4 provides unspeakable limits for operations, please see scientific paper for details.
        UT40_4 is recommended and default, since it is the most compatible with other systems (git, SHA-1, etc)
    &#34;&#34;&#34;

    _n, _id, _ansi_light, _ansi_dark = None, None, None, None
    _sansi_light, _sansi_dark, _sid, _etype, _rgb_light, _rgb_dark = None, None, None, None, None, None

    _etype_inducer, _bits, _ø = None, None, None
    _rev = None
    components_cache_size = 100

    def __init__(self, content, etype=&#34;default:ordered&#34;, version=UT40_4):
        self.version = version
        self.p, self.p4, self.p6, self.digits, self.bytes, _, _, _, _, _, _ = version
        self._composition_memo = {}
        if isinstance(content, (list, tuple)):
            content = tuple(content)
            if etype != &#34;default:ordered&#34;:
                raise DanglingEtype(f&#34;Cannot set etype={etype} when providing cells {content}.&#34;)
            if max(content) &gt;= self.p:
                raise CellValueTooHigh(f&#34;A cell value exceeds the limit for the group: {max(content)} &gt;= {self.p}&#34;)
            self.cells = content
        elif isinstance(content, bytes):
            if etype == &#34;default:ordered&#34;:
                etype = &#34;ordered&#34;
            self.cells, self._id = cells_id_fromblob(content, etype, self.bytes, self.p)
        else:
            raise WrongContent(
                f&#34;No valid content provided: {content}\n&#34; f&#34;It should be a bytes object to be hashed or a list of ints.&#34;
            )

    @property
    def ø(self):
        &#34;&#34;&#34;Identity element compatible with this Hosh object

        Usage:

        &gt;&gt;&gt; from hosh import Hosh
        &gt;&gt;&gt; (b := Hosh(b&#34;23987rg23&#34;)).id
        &#39;J5.uRTue8X4r1xu.JFkPbURVVGvTRPSFLncXdyzj&#39;
        &gt;&gt;&gt; b.etype
        &#39;ordered&#39;
        &gt;&gt;&gt; b.ø.etype
        &#39;unordered&#39;
        &gt;&gt;&gt; b.etype == b.ø.etype_inducer
        True
        &gt;&gt;&gt; b.ø.id
        &#39;0000000000000000000000000000000000000000&#39;
        &gt;&gt;&gt; (b.ø * b&#34;qwer&#34;).etype
        &#39;ordered&#39;
        &#34;&#34;&#34;
        if self._ø is None:
            from hosh import Identity

            self._ø = Identity(version=self.version, etype_inducer=self.etype)
        return self._ø

    @property
    def rev(self):
        &#34;&#34;&#34;
        Reversed element (warning: this is not the inverse element)

        Element with the internal cells reversed.
        This operation is its own inverse.

        This is useful wherever a unary operation is needed.
        For instance, a function can be represented as a value by its original identifier,
        and can be represented as (an applied) function by its reversed element identifier.

        Not all hoshes are digest-reversible, i.e., at the digit level, due to the intrinsic mismatch between base 64 (i.e., a power of two) representation and the group (prime) order.
        Therefore, we must resort to reversing the cells.
        As an exception, unordered elements do have (most) digits reversed as it has only one internal cell.

        Probabilistically irrelevant corner cases:
            The presence of empty cells (i.e., with zero value) might cause migration from one etype to another.
            The presence of duplicate cells (i.e., with the same value) might make the hosh reverse to itself.
            See examples below.

        Usage:

        &gt;&gt;&gt; from hosh import Hosh, groups
        &gt;&gt;&gt; h = Hosh.fromid(&#34;J5.uRTue8X4r1xu.JFkPbURVVGvTRPSFLncXdyzj&#34;).rev
        &gt;&gt;&gt; h.id
        &#39;lUz6uu1ZBCJf342R7-qKOOqWJgaf3TDHx2M.CWGT&#39;
        &gt;&gt;&gt; h.rev.rev == h
        True
        &gt;&gt;&gt; h = Hosh.fromid(&#34;ab_cabcdefabcdefabcdefabcdefabcdefabcdef&#34;)
        &gt;&gt;&gt; h.rev.id
        &#39;Hh_c7201818f76878562c52010943fe4f2a7f3b2&#39;
        &gt;&gt;&gt; h = Hosh.fromid(&#34;2_dbe78441d_____________________________&#34;)
        &gt;&gt;&gt; h.rev.id
        &#39;2_dbd14487e_____________________________&#39;

        &gt;&gt;&gt; # Limits of subgroup Z.
        &gt;&gt;&gt; Hosh.fromid(groups[40].firstp).id,  Hosh.fromid(groups[40].lastp).id
        (&#39;0_100000000_____________________________&#39;, &#39;f_8afffffff_____________________________&#39;)
        &gt;&gt;&gt; Hosh.fromid(groups[40].firstp).rev.id,  Hosh.fromid(groups[40].lastp).rev.id
        (&#39;0_100000000_____________________________&#39;, &#39;f_8afffffff_____________________________&#39;)

        &gt;&gt;&gt; # Limits of subgroup H.
        &gt;&gt;&gt; Hosh.fromid(groups[40].firstp4).id, Hosh.fromid(groups[40].lastp4).id
        (&#39;00_1000000000000000000000000000000000000&#39;, &#39;.._87c2a630003eec7dffff561b0000004aeffff&#39;)
        &gt;&gt;&gt; Hosh.fromid(groups[40].firstp4).rev.id, Hosh.fromid(groups[40].lastp4).rev.id
        (&#39;00_9ed100000015ffffffff00000000000000000&#39;, &#39;.._87c2a630003eec7dffff561b0000004aeffff&#39;)
        &gt;&gt;&gt; Hosh.fromid(groups[40].firstp4).cells, Hosh.fromid(groups[40].lastp4).cells
        ((0, 0, 0, 0, 1, 0), (0, 0, 1099511627688, 1099511627688, 1099511627688, 1099511627688))
        &gt;&gt;&gt; Hosh.fromid(groups[40].firstp4).rev.cells, Hosh.fromid(groups[40].lastp4).rev.cells
        ((0, 0, 0, 1, 0, 0), (0, 0, 1099511627688, 1099511627688, 1099511627688, 1099511627688))

        &gt;&gt;&gt; # Limits of group G.
        &gt;&gt;&gt; Hosh.fromid(groups[40].firstp6).id, Hosh.fromid(groups[40].lastp6).id
        (&#39;1000000000000000000000000000000000000000&#39;, &#39;g-8KOjCQREq2Vz8VTc30gLMd..vvX6000ov.....&#39;)
        &gt;&gt;&gt; Hosh.fromid(groups[40].firstp6).rev.id, Hosh.fromid(groups[40].lastp6).rev.id
        (&#39;00_1000000000000000000000000000000000000&#39;, &#39;g-8KOjCQREq2Vz8VTc30gLMd..vvX6000ov.....&#39;)
        &gt;&gt;&gt; Hosh.fromid(groups[40].firstp6).cells, Hosh.fromid(groups[40].lastp6).cells
        ((0, 1, 0, 0, 0, 0), (1099511627688, 1099511627688, 1099511627688, 1099511627688, 1099511627688, 1099511627688))
        &gt;&gt;&gt; Hosh.fromid(groups[40].firstp6).rev.cells, Hosh.fromid(groups[40].lastp6).rev.cells
        ((0, 0, 0, 0, 1, 0), (1099511627688, 1099511627688, 1099511627688, 1099511627688, 1099511627688, 1099511627688))

        &gt;&gt;&gt; # Near limits of group G.
        &gt;&gt;&gt; Hosh.fromn(groups[40].p4+1).id, Hosh.fromn(groups[40].p6 - 2).id
        (&#39;2000000000000000000000000000000000000000&#39;, &#39;f-8KOjCQREq2Vz8VTc30gLMd..vvX6000ov.....&#39;)
        &gt;&gt;&gt; Hosh.fromn(groups[40].p4+1).rev.id, Hosh.fromn(groups[40].p6 - 2).rev.id
        (&#39;ihdwjXvMdIj40gZQq-..5Ai0000j-....3000000&#39;, &#39;7XoPrombpt9-UXQnse30Cgud..fcZ6000kv.....&#39;)
        &gt;&gt;&gt; Hosh.fromn(groups[40].p4+1).cells, Hosh.fromn(groups[40].p6 - 2).cells
        ((0, 1, 0, 0, 0, 1), (1099511627688, 1099511627688, 1099511627688, 1099511627688, 1099511627688, 1099511627687))
        &gt;&gt;&gt; Hosh.fromn(groups[40].p4+1).rev.cells, Hosh.fromn(groups[40].p6 - 2).rev.cells
        ((1, 0, 0, 0, 1, 0), (1099511627687, 1099511627688, 1099511627688, 1099511627688, 1099511627688, 1099511627688))
        &#34;&#34;&#34;
        if self._rev is None:
            id = self.id
            if self.etype == &#34;ordered&#34;:
                self._rev = Hosh(tuple(reversed(self.cells)))
            elif self.etype == &#34;hybrid&#34;:
                self._rev = Hosh(self.cells[:2] + tuple(reversed(self.cells[2:])))
            elif self.etype == &#34;unordered&#34;:
                self._rev = Hosh.fromid(id[:4] + &#34;&#34;.join(reversed(id[4:11])) + &#34;_____________________________&#34;)
            else:  # pragma: no cover
                raise Exception(f&#34;Unexpected condition. element type: {self.etype}&#34;)
        return self._rev

    @property
    def etype(self):
        &#34;&#34;&#34;
        Type of this element

        Usage:

        &gt;&gt;&gt; from hosh import Hosh
        &gt;&gt;&gt; Hosh.fromn(5).etype
        &#39;unordered&#39;

        Returns
        -------
        &#39;ordered&#39;, &#39;hybrid&#39; or &#39;unordered&#39;
        &#34;&#34;&#34;
        if self._etype is None:
            if sum(self.cells[:5]) == 0:
                self._etype = &#34;unordered&#34;
            elif sum(self.cells[:2]) == 0:
                self._etype = &#34;hybrid&#34;
            else:
                self._etype = &#34;ordered&#34;
        return self._etype

    @property
    def etype_inducer(self):
        &#34;&#34;&#34;
        Type this element uses to coerce an element of undefined type.

        Usage:

        &gt;&gt;&gt; from hosh import ø, Hosh
        &gt;&gt;&gt; ø.etype_inducer
        &#39;ordered&#39;
        &gt;&gt;&gt; ø.h.etype_inducer
        &#39;hybrid&#39;
        &gt;&gt;&gt; ø.u.etype_inducer
        &#39;unordered&#39;
        &gt;&gt;&gt; Hosh(b&#34;12124&#34;).etype_inducer
        &#39;ordered&#39;
        &gt;&gt;&gt; Hosh(b&#34;12124&#34;, etype=&#34;hybrid&#34;).etype_inducer
        &#39;hybrid&#39;

        Returns
        -------
        &#39;ordered&#39;, &#39;hybrid&#39;, &#39;unordered&#39;
        &#34;&#34;&#34;
        if self._etype_inducer is None:
            self._etype_inducer = self.etype
        return self._etype_inducer

    @property
    def id(self):
        &#34;&#34;&#34;
        Textual representation of this element

        Returns
        -------
        Textual representation
        &#34;&#34;&#34;
        if self._id is None:
            self._id = id_fromcells(self.cells, self.digits, self.p)
        return self._id

    @classmethod
    def fromid(cls, id):
        &#34;&#34;&#34;
        Create an element from a textual id.

        Usage:

        &gt;&gt;&gt; a = Hosh.fromid(&#34;abcdefabcdefabcdefabcdefabcdefab&#34;)
        &gt;&gt;&gt; a.n
        1094566309952642687224764830259410933250743749332933330234
        &gt;&gt;&gt; a.cells
        (748932665, 516513868, 468764361, 3316970622, 2727293743, 316029245)
        &gt;&gt;&gt; a.etype
        &#39;ordered&#39;
        &gt;&gt;&gt; bid = a.id[:2] + &#34;_&#34; + a.id[3:]
        &gt;&gt;&gt; bid
        &#39;ab_defabcdefabcdefabcdefabcdefab&#39;
        &gt;&gt;&gt; b = Hosh.fromid(bid)
        &gt;&gt;&gt; b.id
        &#39;ab_defabcdefabcdefabcdefabcdefab&#39;
        &gt;&gt;&gt; b.n
        59377482839139050825606534576063885287
        &gt;&gt;&gt; b.cells
        (0, 0, 749449200, 1774140626, 3139018916, 292801225)
        &gt;&gt;&gt; b.etype
        &#39;hybrid&#39;
        &gt;&gt;&gt; Hosh.fromid(&#34;0000000000000000000000000000000000000000000000000000000000000000&#34;) == 0
        True

        Parameters
        ----------
        id

        Parameters
        ----------
        id

        Returns
        -------
        A new Hosh object
        &#34;&#34;&#34;

        if len(id) not in groups:
            raise WrongIdentifier(f&#34;Wrong identifier length: {len(id)}   id:[{id}]&#34;)
        return Hosh(cells_fromid(id, p=groups[len(id)].p), version=groups[len(id)])

    @classmethod
    def fromn(cls, n: int, version=UT40_4):
        &#34;&#34;&#34;
        Create a Hosh object representing the given int.

        Usage:

        &gt;&gt;&gt; h = Hosh.fromn(7647544756746324134134)
        &gt;&gt;&gt; h.id
        &#39;00_e49c1c505dcd0039e91000000000000000000&#39;

        Parameters
        ----------
        n
        version

        Returns
        -------
        A new Hosh object
        &#34;&#34;&#34;
        p, order = version.p, version.p6
        if n &gt; order:
            raise ElementTooHigh(f&#34;Element outside allowed range: {n} &gt;= {order}&#34;)
        return Hosh(int2cells(n, p), version=version)

    @classmethod
    def fromtensor(cls, tensor, device=None, version=UT40_4):
        &#34;&#34;&#34;
        Create a Hosh object representing the given tensor.

        Vectorized pure-Torch implementation producing 6 ints from tensor T.
        If `device` is provided and is a CUDA device, this can run on GPU.

        Usage:
        TODO: add example and generalize to other versions other than UT40_4 (need to adjust null case, multipliers, adds, and mod p)

        Parameters
        ----------
        tensor
        device
        version

        Returns
        -------
        A new Hosh object
        &#34;&#34;&#34;
        if version != &#34;UT40_4&#34;:
            raise NotImplementedError(f&#34;Unsupported version: {version}&#34;)
        import torch
        arr = tensor.reshape(-1).to(torch.int64)
        if device is not None:
            arr = arr.to(device)
        if arr.numel() == 0:
            return Hosh([0] * 6, version=version)
        # 6 distinct multipliers/adds (int64) placed on the same device as arr
        mults = torch.tensor([1315423911, 2654435761, 97531, 1000003, 1000000007, 1610612741], dtype=torch.int64, device=arr.device).unsqueeze(1)
        adds = torch.tensor([2654435761, 97531, 1000003, 1000000007, 1610612741, 1315423911], dtype=torch.int64, device=arr.device).unsqueeze(1)
        mask64 = (1 &lt;&lt; 64) - 1
        mixed = arr.unsqueeze(0) * mults
        mixed = mixed + adds
        mixed = mixed ^ (mixed &gt;&gt; 23)
        sums = mixed.sum(dim=1)
        out = []
        for s in sums:
            s_int = int(s.item()) &amp; mask64
            out.append(int(s_int % version.p))
        return Hosh(out, version=version)

    @property
    def n(self):
        &#34;&#34;&#34;
        Lexicographic rank of this eloement (according to the format adopted in internal integer cells.

        Returns
        -------
        Number
        &#34;&#34;&#34;
        if self._n is None:
            self._n = cells2int(self.cells, self.p)
        return self._n

    @property
    def sid(self):
        &#34;&#34;&#34;
        Shorter id (base-777 using up to 2 bytes utf8 per char)

        Usage:

        &gt;&gt;&gt; from hosh import ø
        &gt;&gt;&gt; (ø * b&#39;65e987978g&#39;).sid
        &#39;ȟɟìӧДɫŖāöơɟբƢŊþXÊϱՎҲģţՀɄЌ&#39;

        Returns
        -------
        Short utf-8 textual representation
        &#34;&#34;&#34;
        if self._sid is None:
            self._sid = b777enc(self.n, self.digits * 5 // 8)
        return self._sid

    @property
    def ansi(self):
        r&#34;&#34;&#34;
        Colored textual (ANSI) representation of this element

        &gt;&gt;&gt; from hosh import Hosh
        &gt;&gt;&gt; Hosh.fromid(&#34;Iaz3L67a2BQv0GifoWOjWale6LYFTGmJJ1ZPfdoP&#34;).ansi
        &#39;\x1b[38;5;229m\x1b[1m\x1b[48;5;0mI\x1b[0m\x1b[38;5;228m\x1b[1m\x1b[48;5;0ma\x1b[0m\x1b[38;5;222m\x1b[1m\x1b[48;5;0mz\x1b[0m\x1b[38;5;223m\x1b[1m\x1b[48;5;0m3\x1b[0m\x1b[38;5;228m\x1b[1m\x1b[48;5;0mL\x1b[0m\x1b[38;5;222m\x1b[1m\x1b[48;5;0m6\x1b[0m\x1b[38;5;222m\x1b[1m\x1b[48;5;0m7\x1b[0m\x1b[38;5;223m\x1b[1m\x1b[48;5;0ma\x1b[0m\x1b[38;5;228m\x1b[1m\x1b[48;5;0m2\x1b[0m\x1b[38;5;221m\x1b[1m\x1b[48;5;0mB\x1b[0m\x1b[38;5;216m\x1b[1m\x1b[48;5;0mQ\x1b[0m\x1b[38;5;186m\x1b[1m\x1b[48;5;0mv\x1b[0m\x1b[38;5;222m\x1b[1m\x1b[48;5;0m0\x1b[0m\x1b[38;5;221m\x1b[1m\x1b[48;5;0mG\x1b[0m\x1b[38;5;181m\x1b[1m\x1b[48;5;0mi\x1b[0m\x1b[38;5;194m\x1b[1m\x1b[48;5;0mf\x1b[0m\x1b[38;5;229m\x1b[1m\x1b[48;5;0mo\x1b[0m\x1b[38;5;228m\x1b[1m\x1b[48;5;0mW\x1b[0m\x1b[38;5;222m\x1b[1m\x1b[48;5;0mO\x1b[0m\x1b[38;5;223m\x1b[1m\x1b[48;5;0mj\x1b[0m\x1b[38;5;228m\x1b[1m\x1b[48;5;0mW\x1b[0m\x1b[38;5;222m\x1b[1m\x1b[48;5;0ma\x1b[0m\x1b[38;5;222m\x1b[1m\x1b[48;5;0ml\x1b[0m\x1b[38;5;223m\x1b[1m\x1b[48;5;0me\x1b[0m\x1b[38;5;228m\x1b[1m\x1b[48;5;0m6\x1b[0m\x1b[38;5;221m\x1b[1m\x1b[48;5;0mL\x1b[0m\x1b[38;5;216m\x1b[1m\x1b[48;5;0mY\x1b[0m\x1b[38;5;186m\x1b[1m\x1b[48;5;0mF\x1b[0m\x1b[38;5;222m\x1b[1m\x1b[48;5;0mT\x1b[0m\x1b[38;5;221m\x1b[1m\x1b[48;5;0mG\x1b[0m\x1b[38;5;181m\x1b[1m\x1b[48;5;0mm\x1b[0m\x1b[38;5;194m\x1b[1m\x1b[48;5;0mJ\x1b[0m\x1b[38;5;229m\x1b[1m\x1b[48;5;0mJ\x1b[0m\x1b[38;5;228m\x1b[1m\x1b[48;5;0m1\x1b[0m\x1b[38;5;222m\x1b[1m\x1b[48;5;0mZ\x1b[0m\x1b[38;5;223m\x1b[1m\x1b[48;5;0mP\x1b[0m\x1b[38;5;228m\x1b[1m\x1b[48;5;0mf\x1b[0m\x1b[38;5;222m\x1b[1m\x1b[48;5;0md\x1b[0m\x1b[38;5;222m\x1b[1m\x1b[48;5;0mo\x1b[0m\x1b[38;5;223m\x1b[1m\x1b[48;5;0mP\x1b[0m&#39;

        Returns
        -------
        Textual representation
        &#34;&#34;&#34;
        if self._ansi_light is None:
            self._ansi_light, self._ansi_dark = id2ansi(self.id)
        return self._ansi_dark if GLOBAL[&#34;dark_theme&#34;] else self._ansi_light

    @property
    def idc(self):  # pragma: no cover
        print(&#34;&#39;hosh.idc&#39; is deprecated, use &#39;hosh.ansi&#39; instead&#34;)
        return self.ansi

    @property
    def rgb(self):
        &#34;&#34;&#34;
        Colored textual (RGB) representation of this element

        &gt;&gt;&gt; from hosh import Hosh
        &gt;&gt;&gt; Hosh.fromid(&#34;Iaz3L67a2BQv0GifoWOjWale6LYFTGmJJ1ZPfdoP&#34;).rgb
        [[6, 28, 104], [255, 255, 184], [255, 255, 141], [255, 220, 155], [255, 233, 172], [255, 250, 139], [255, 218, 144], [254, 223, 150], [255, 229, 187], [255, 255, 127], [255, 206, 98], [242, 176, 123], [212, 201, 138], [237, 216, 120], [252, 198, 115], [234, 193, 174], [229, 253, 204], [255, 255, 184], [255, 255, 141], [255, 220, 155], [255, 233, 172], [255, 250, 139], [255, 218, 144], [254, 223, 150], [255, 229, 187], [255, 255, 127], [255, 206, 98], [242, 176, 123], [212, 201, 138], [237, 216, 120], [252, 198, 115], [234, 193, 174], [229, 253, 204], [255, 255, 184], [255, 255, 141], [255, 220, 155], [255, 233, 172], [255, 250, 139], [255, 218, 144], [254, 223, 150], [255, 229, 187]]
        &#34;&#34;&#34;
        if self._rgb_light is None:
            self._rgb_light, self._rgb_dark = id2rgb(self.id)
        return self._rgb_dark if GLOBAL[&#34;dark_theme&#34;] else self._rgb_light

    @property
    def html(self):
        &#34;&#34;&#34;
        HTML page containing a colored textual representation of this element

        Returns
        -------
        Textual representation
        &#34;&#34;&#34;
        return ansi2html(self.ansi)

    @property
    def shtml(self):
        &#34;&#34;&#34;Short colored html digest&#34;&#34;&#34;
        return ansi2html(self.sansi)

    @property
    def sidc(self):  # pragma: no cover
        print(&#34;&#39;hosh.sidc&#39; is deprecated, please use &#39;hosh.sansi&#39; instead&#34;)
        return self.sansi

    @property
    def sansi(self):
        &#34;&#34;&#34;
        Shorter colored id (base-777 using up to 2 bytes utf8 per char)

        Usage:

        &gt;&gt;&gt; from hosh import ø
        &gt;&gt;&gt; print((ø * b&#39;65e987978g&#39;).sansi)
        \x1b[38;5;156m\x1b[1m\x1b[48;5;0mȟ\x1b[0m\x1b[38;5;155m\x1b[1m\x1b[48;5;0mɟ\x1b[0m\x1b[38;5;185m\x1b[1m\x1b[48;5;0mì\x1b[0m\x1b[38;5;113m\x1b[1m\x1b[48;5;0mӧ\x1b[0m\x1b[38;5;119m\x1b[1m\x1b[48;5;0mД\x1b[0m\x1b[38;5;185m\x1b[1m\x1b[48;5;0mɫ\x1b[0m\x1b[38;5;113m\x1b[1m\x1b[48;5;0mŖ\x1b[0m\x1b[38;5;119m\x1b[1m\x1b[48;5;0mā\x1b[0m\x1b[38;5;149m\x1b[1m\x1b[48;5;0mö\x1b[0m\x1b[38;5;113m\x1b[1m\x1b[48;5;0mơ\x1b[0m\x1b[38;5;83m\x1b[1m\x1b[48;5;0mɟ\x1b[0m\x1b[38;5;155m\x1b[1m\x1b[48;5;0mբ\x1b[0m\x1b[38;5;149m\x1b[1m\x1b[48;5;0mƢ\x1b[0m\x1b[38;5;119m\x1b[1m\x1b[48;5;0mŊ\x1b[0m\x1b[38;5;185m\x1b[1m\x1b[48;5;0mþ\x1b[0m\x1b[38;5;119m\x1b[1m\x1b[48;5;0mX\x1b[0m\x1b[38;5;156m\x1b[1m\x1b[48;5;0mÊ\x1b[0m\x1b[38;5;155m\x1b[1m\x1b[48;5;0mϱ\x1b[0m\x1b[38;5;185m\x1b[1m\x1b[48;5;0mՎ\x1b[0m\x1b[38;5;113m\x1b[1m\x1b[48;5;0mҲ\x1b[0m\x1b[38;5;119m\x1b[1m\x1b[48;5;0mģ\x1b[0m\x1b[38;5;185m\x1b[1m\x1b[48;5;0mţ\x1b[0m\x1b[38;5;113m\x1b[1m\x1b[48;5;0mՀ\x1b[0m\x1b[38;5;119m\x1b[1m\x1b[48;5;0mɄ\x1b[0m\x1b[38;5;149m\x1b[1m\x1b[48;5;0mЌ\x1b[0m

        Returns
        -------
        Short utf-8 colored textual representation
        &#34;&#34;&#34;
        if self._sansi_light is None:
            self._sansi_light, self._sansi_dark = id2ansi(self.sid)
        return self._sansi_dark if GLOBAL[&#34;dark_theme&#34;] else self._sansi_light

    def __repr__(self):
        if GLOBAL[&#34;format&#34;] == BW:
            return self.sid if GLOBAL[&#34;short&#34;] else self.id
        elif GLOBAL[&#34;format&#34;] == ANSI:
            return self.sansi if GLOBAL[&#34;short&#34;] else self.ansi
        elif GLOBAL[&#34;format&#34;] == HTML:
            return self.shtml if GLOBAL[&#34;short&#34;] else self.html
        elif callable(GLOBAL[&#34;format&#34;]):  # pragma: no cover
            return GLOBAL[&#34;format&#34;](self)
        else:  # pragma: no cover
            raise Exception(f&#34;Unknown format: {GLOBAL[&#39;format&#39;]}&#34;)

    def __xor__(self, other: int):
        if other == 1:
            return self
        return Hosh(cellspow(self.cells, other, self.p), version=self.version)

    def __mul__(self, other: Union[&#34;Hosh&#34;, str, bytes, int]):
        if (other := self.convert(other)) is NotImplemented:  # pragma: no cover
            return NotImplemented
        return Hosh(cellsmul(self.cells, other.cells, self.p), version=self.version)

    def __rmul__(self, other: Union[&#34;Hosh&#34;, str, bytes, int]):
        &#34;&#34;&#34;
        &gt;&gt;&gt; from hosh import ø
        &gt;&gt;&gt; (ø * b&#34;13dfv34y4&#34; )* b&#34;434vbfrdg&#34; == b&#34;13dfv34y4&#34; * (ø * b&#34;434vbfrdg&#34;)
        True

        Parameters
        ----------
        other

        Returns
        -------

        &#34;&#34;&#34;
        if (other := self.convert(other)) is NotImplemented:  # pragma: no cover
            return NotImplemented
        return Hosh(cellsmul(other.cells, self.cells, self.p), version=self.version)

    def __rpow__(self, other):
        &#34;&#34;&#34;
        &gt;&gt;&gt; from hosh import ø
        &gt;&gt;&gt; (ø * b&#34;13dfv34y4&#34;) ** b&#34;434vbfrdg&#34; == b&#34;13dfv34y4&#34; ** (ø * b&#34;434vbfrdg&#34;)
        True

        Parameters
        ----------
        other

        Returns
        -------

        &#34;&#34;&#34;
        if (other := self.convert(other)) is NotImplemented:  # pragma: no cover
            return NotImplemented
        return +(+other * +self)

    def __pow__(self, power, modulo=None):
        if (power := self.convert(power)) is NotImplemented:  # pragma: no cover
            return NotImplemented
        return +(+self * +power)

    def __rfloordiv__(self, other):
        &#34;&#34;&#34;
        &gt;&gt;&gt; from hosh import ø
        &gt;&gt;&gt; (ø * b&#34;13dfv34y4&#34;) // b&#34;434vbfrdg&#34; == b&#34;13dfv34y4&#34; // (ø * b&#34;434vbfrdg&#34;)
        True

        Parameters
        ----------
        other

        Returns
        -------

        &#34;&#34;&#34;
        if (other := self.convert(other)) is NotImplemented:  # pragma: no cover
            return NotImplemented
        return +(+other / +self)

    def __floordiv__(self, other):
        &#34;&#34;&#34;Lift&#34;&#34;&#34;
        if (other := self.convert(other)) is NotImplemented:  # pragma: no cover
            return NotImplemented
        return +(+self / +other)

    def __neg__(self):
        return Hosh(cellsinv(self.cells, self.p, additive=True), version=self.version)

    def __pos__(self):
        &#34;&#34;&#34;Change disposition of element-matrix cells in a way that even hybrid ids will not commute.
        ps. Semantics of +hosh are completely unrelated from -hosh as -hosh creates the inverse additive element.

        Switch positions of cells a2 and a5. This operation is its own inverse.

        Cells are represented as a tuple in the format: (a5, a4, a3, a2, a1, a0)
        Cells are represented as a matrix in the format:
        1 a4 a1 a0
        0  1 a2 a3
        0  0  1 a5
        0  0  0  1

        &#34;&#34;&#34;
        cells = self.cells
        return Hosh((cells[3], cells[1], cells[2], cells[0], cells[4], cells[5]), version=self.version)

    def __invert__(self):
        return Hosh(cellsinv(self.cells, self.p), version=self.version)

    def __rtruediv__(self, other):
        &#34;&#34;&#34;
        &gt;&gt;&gt; from hosh import ø
        &gt;&gt;&gt; (ø * b&#34;13dfv34y4&#34;) / b&#34;434vbfrdg&#34; == b&#34;13dfv34y4&#34; / (ø * b&#34;434vbfrdg&#34;)
        True

        Parameters
        ----------
        other

        Returns
        -------

        &#34;&#34;&#34;
        if (other := self.convert(other)) is NotImplemented:  # pragma: no cover
            return NotImplemented
        return Hosh(cellsmul(other.cells, cellsinv(self.cells, self.p), self.p), version=self.version)

    def __truediv__(self, other):
        if (other := self.convert(other)) is NotImplemented:  # pragma: no cover
            return NotImplemented
        return Hosh(cellsmul(self.cells, cellsinv(other.cells, self.p), self.p), version=self.version)

    def __add__(self, other):
        &#34;&#34;&#34;Matrix addition modulo p, keeping unidiagonal&#34;&#34;&#34;
        if (other := self.convert(other)) is NotImplemented:  # pragma: no cover
            return NotImplemented
        cells = tuple(map(lambda x, y: (x + y) % self.p, self.cells, other.cells))
        return Hosh(cells, version=self.version)

    def __sub__(self, other):  # TODO: check if a - b  here is different from a + (-b) ?
        &#34;&#34;&#34;Matrix subtraction modulo p, keeping unidiagonal&#34;&#34;&#34;
        if (other := self.convert(other)) is NotImplemented:  # pragma: no cover
            return NotImplemented
        cells = tuple(map(lambda x, y: (x - y) % self.p, self.cells, other.cells))
        return Hosh(cells, version=self.version)
        # REMINDER: the chosen implementation differs from the alternative bellow!
        # return Hosh.fromn((self.n + self.convert(other).n) % self.order, self.version)

    def __str__(self):
        return self.sid if GLOBAL[&#34;short&#34;] else self.id

    def __eq__(self, other):
        if (other := self.convert(other)) is NotImplemented:  # pragma: no cover
            return NotImplemented
        return self.n == other.n

    def __ne__(self, other):
        if (other := self.convert(other)) is NotImplemented:  # pragma: no cover
            return NotImplemented
        return self.n != other.n

    def show(self, colored=True):
        &#34;&#34;&#34;
        Usage:

        &gt;&gt;&gt; Hosh(b&#34;asdf86fasd&#34;).show(colored=False)
        voh8t1KrYmzCqpyrUO9.5QbGdouoZsnExarMSa34
        &#34;&#34;&#34;
        return print(self.ansi if colored else self.id)

    def short(self, colored=True):
        &#34;&#34;&#34;
        Usage:

        &gt;&gt;&gt; Hosh(b&#34;asdf86fasd&#34;).short(colored=False)
        lϊӑơӫǯÃϺŮϳȐŁЬĽҪƉǏԛȪƜfÞӠȕՇ
        &#34;&#34;&#34;
        return print(self.sansi if colored else self.sid)

    def __hash__(self):
        return self.n % maxsize

    def convert(self, other):
        &#34;&#34;&#34;
        Usage:

        &gt;&gt;&gt; from hosh import ø
        &gt;&gt;&gt; ø.convert([0,0,0,0,0,0]).id
        &#39;0000000000000000000000000000000000000000&#39;

        &gt;&gt;&gt; from hosh import Hosh
        &gt;&gt;&gt; ø.convert(0).id
        &#39;0000000000000000000000000000000000000000&#39;

        Parameters
        ----------
        other

        Returns
        -------

        &#34;&#34;&#34;
        if isinstance(other, str):
            other = Hosh.fromid(other)
        elif isinstance(other, bytes):
            other = Hosh(other, etype=self.etype_inducer, version=self.version)
        elif isinstance(other, int):
            other = Hosh.fromn(other, version=self.version)
        elif isinstance(other, (tuple | list)):
            other = Hosh(other, version=self.version)
        elif not isinstance(other, Hosh):
            return NotImplemented
        if self.version != other.version:
            raise WrongVersion(f&#34;Incompatible operands: {self.version} != {other.version}&#34;)
        return other

    def root(self, k):
        &#34;&#34;&#34;
        &gt;&gt;&gt; a = Hosh(b&#34;a&#34;)
        &gt;&gt;&gt; for i in range(1, 5):
        ...     r = a.root(i)
        ...     r^i == a
        True
        True
        True
        True
        &#34;&#34;&#34;
        if k == 1:
            return self
        return Hosh(cellsroot(self.cells, k, self.p), version=self.version)

    def power_component(self, i, n):
        &#34;&#34;&#34;Elements corresponding to `n` components of &#34;multiplicative decomposition&#34; such that
        `x  =  x1 * x2 * x3 * ... * xn  =  x * x² * x³ * ... * x^n`

        Not very useful as the resulting elements commute among themselves.
        This happens because they are all powers of x, making up just a sequence of `x`s .

        Parameters
        ==========
        i
            Desired component index
        n
            Desired total number of components

        Returns
        =======
            Hosh (component)

        &gt;&gt;&gt; a = Hosh(b&#34;a&#34;)
        &gt;&gt;&gt; a.power_component(0, 1) == a
        True
        &gt;&gt;&gt; a.power_component(0, 2) * a.power_component(1, 2) == a
        True
        &gt;&gt;&gt; a.power_component(0, 3) * a.power_component(1, 3) * a.power_component(2, 3) == a
        True
        &gt;&gt;&gt; a.power_component(2, 3) * a.power_component(1, 3) * a.power_component(0, 3) == a
        True
        &#34;&#34;&#34;
        if i &gt;= n:  # pragma: no cover
            raise Exception(f&#34;Hosh component should be defined by &#39;index&#39; ({i}) &lt; &#39;#components&#39; ({n})&#34;)
        if n == 1:
            return self
        exp = n * (n + 1) // 2
        r = self.root(exp)
        return r ^ (i + 1)

    def bad_additive_components(self, n):
        &#34;&#34;&#34;
        Return the `n` additive components for `x` such that `x = x1 + x2 + ... + xn`

        `xn` fills the gap left by the other components remainder.
        We do not recommend this &#34;decomposition&#34; as it always generates different ids for the same subvalue.
        For instance,
            if a list `[value1, value2, value3]` induces ids `a`, `b`, and `any`,
             another list `[value1, value2, ...]` necessarily induces `c` and `d` as first two ids such that `a != c` and `b != d`.

        Parameters
        ==========
        n
            Desired total number of components

        Returns
        =======
            Generator of hoshes

        &gt;&gt;&gt; from functools import reduce
        &gt;&gt;&gt; import operator
        &gt;&gt;&gt; reduce(operator.add, Hosh(b&#34;x&#34;).bad_additive_components(5)) == Hosh(b&#34;x&#34;)
        True
        &#34;&#34;&#34;
        den = n * (n + 1) // 2
        p = self.p

        def fac(x):
            parc, rem = divmod(x + p, den)
            lst = [i * parc for i in range(1, n + 1)]
            lst[-1] += rem
            return [l % p for l in lst]

        return (Hosh(tuple(x), version=self.version) for x in zip(*(fac(c) for c in self.cells)))

    def bad_additive_component(self, i, n):
        &#34;&#34;&#34;
        Return the `i`-th additive component for `x` such that `x = x1 + x2 + ... + xn`

        See `bad_additive_components` for more details.

        &gt;&gt;&gt; from functools import reduce
        &gt;&gt;&gt; import operator
        &gt;&gt;&gt; list(Hosh(b&#34;x&#34;).bad_additive_components(2))[0] == Hosh(b&#34;x&#34;).bad_additive_component(0, 2)
        True
        &gt;&gt;&gt; list(Hosh(b&#34;x&#34;).bad_additive_components(2))[1] == Hosh(b&#34;x&#34;).bad_additive_component(1, 2)
        True
        &gt;&gt;&gt; list(Hosh(b&#34;x&#34;).bad_additive_components(3))[0] == Hosh(b&#34;x&#34;).bad_additive_component(0, 3)
        True
        &gt;&gt;&gt; list(Hosh(b&#34;x&#34;).bad_additive_components(3))[1] == Hosh(b&#34;x&#34;).bad_additive_component(1, 3)
        True
        &gt;&gt;&gt; list(Hosh(b&#34;x&#34;).bad_additive_components(3))[2] == Hosh(b&#34;x&#34;).bad_additive_component(2, 3)
        True
        &gt;&gt;&gt; list(Hosh(b&#34;x&#34;).bad_additive_components(5))[0] == Hosh(b&#34;x&#34;).bad_additive_component(0, 5)
        True
        &gt;&gt;&gt; list(Hosh(b&#34;x&#34;).bad_additive_components(5))[1] == Hosh(b&#34;x&#34;).bad_additive_component(1, 5)
        True
        &gt;&gt;&gt; list(Hosh(b&#34;x&#34;).bad_additive_components(5))[2] == Hosh(b&#34;x&#34;).bad_additive_component(2, 5)
        True
        &gt;&gt;&gt; list(Hosh(b&#34;x&#34;).bad_additive_components(5))[4] == Hosh(b&#34;x&#34;).bad_additive_component(4, 5)
        True
        &gt;&gt;&gt; list(Hosh(b&#34;x&#34;).bad_additive_components(7))[0] == Hosh(b&#34;x&#34;).bad_additive_component(0, 7)
        True
        &gt;&gt;&gt; list(Hosh(b&#34;x&#34;).bad_additive_components(7))[1] == Hosh(b&#34;x&#34;).bad_additive_component(1, 7)
        True
        &gt;&gt;&gt; list(Hosh(b&#34;x&#34;).bad_additive_components(7))[2] == Hosh(b&#34;x&#34;).bad_additive_component(2, 7)
        True
        &gt;&gt;&gt; list(Hosh(b&#34;x&#34;).bad_additive_components(7))[4] == Hosh(b&#34;x&#34;).bad_additive_component(4, 7)
        True
        &#34;&#34;&#34;
        den = n * (n + 1) // 2
        p = self.p
        i += 1
        toggle = 1 if i == n else 0

        def fac(x):
            parc, rem = divmod(x + p, den)
            return (i * parc + toggle * rem) % p

        return Hosh(tuple(fac(c) for c in self.cells), version=self.version)

    def components(self, start, stop, n, additive=False):
        r&#34;&#34;&#34;
        Pseudo&#34;decomposition&#34; based on the hosh of the current id concatenated as bytes to a given component index

        Perform a multiplicative decomposition by default.

        Syntax:
            Hosh(b&#34;blob&#34;).components(i, m, n)   # Takes a slice of elements.
            Hosh(b&#34;blob&#34;)[i:m, n]               # Takes a slice of elements.
            Hosh(b&#34;blob&#34;)[i, n]                 # Takes element `i` out of `n` components.
            Hosh(b&#34;blob&#34;)[:n, n]                # All `n` elements.
        Warning:
            Hosh(b&#34;blob&#34;)[-1]                   # Reverse element. Not to be confused with inverse element.


        The components are arbitrarily internally defined group elements based on current id as hashed bytes:
        Hosh(id+&#34;-1&#34;), Hosh(id+&#34;-2&#34;), ..., Hosh(id+&#34;-n&#34;)

        The last element (xn) is the exception as it makes the product x1 * x2 * ... * xn match x:
        x1      = id+&#34;-1&#34; * x
         ...
        xn-1    = id+&#34;-n-1&#34; * x
        xn      = (id+&#34;-1&#34; * x * ... * id+&#34;-n-1&#34;)-¹

        Parameters
        ==========
        start
            Start of a slice
        stop
            Stop of a slice
        n
            Desired total number of components
        additive
            Set up an additive decomposition

        Returns
        =======
            List if hoshes

        &gt;&gt;&gt; from hosh import Hosh
        &gt;&gt;&gt; a = Hosh(b&#34;a&#34;)
        &gt;&gt;&gt; a[-1].rev == a
        True
        &gt;&gt;&gt; a[0, 1] == a
        True
        &gt;&gt;&gt; a[0:, 1][0] == a
        True
        &gt;&gt;&gt; a[:1, 1][0] == a
        True
        &gt;&gt;&gt; a[0:1, 1][0] == a
        True
        &gt;&gt;&gt; from operator import mul
        &gt;&gt;&gt; reduce(mul, a[:, 3]) == a
        True
        &gt;&gt;&gt; [x.id for x in a[:, 3]]
        [&#39;Bd6Axil5pFSp15HUBz8eCujvu3gBsEk6XMpRsMNo&#39;, &#39;32MloLPcivDbbPMCJn1RBY31aNZ6z-Dqnt4vQhot&#39;, &#39;la3xnZmlhn3lFBAnvWw-UWAvK.2hk-QqUNFYAs3e&#39;]
        &gt;&gt;&gt; a[:, 3][0] * a[:, 3][1] * a[:, 3][2] == a
        True
        &gt;&gt;&gt; a[0, 3] * a[1, 3] * a[2, 3] == a
        True
        &gt;&gt;&gt; a.id
        &#39;cIXBKPediDiOKabeZ6SthD04rnzaquNXaAEhSud4&#39;
        &gt;&gt;&gt; from operator import add, mul
        &gt;&gt;&gt; from functools import reduce
        &gt;&gt;&gt; print(&#34;\n&#34;.join(x.id for x in a.components(0, 7, 7)))
        Bd6Axil5pFSp15HUBz8eCujvu3gBsEk6XMpRsMNo
        32MloLPcivDbbPMCJn1RBY31aNZ6z-Dqnt4vQhot
        Y2JlyuF8.KJc0DvvcIivLA5uLYloF7HN9ovO14Sq
        6.F-NB-G4vBXs7evbBImex9x3foNi85Ca7wDb1c3
        tZmUsjVcZAGTajUOzsSNrr7a7BQVNSiA6xaiPEYf
        iCLMdAlduXvUtK1.awng0D0YP49kV8Cit7OLXyab
        BA6UvITsIN822llT9eErc1R0rmf.ARbc0adwEbWk
        &gt;&gt;&gt; reduce(mul, a.components(0, 2, 7)) * reduce(mul, a.components(2, 3, 7)) * reduce(mul, a.components(3, 7, 7)) == a
        True
        &gt;&gt;&gt; reduce(mul, a.components(0, 7, 7)) == a
        True

        &gt;&gt;&gt; print(&#34;\n&#34;.join(x.id for x in a.components(0, 7, 7, additive=True)))
        Bd6Axil5pFSp15HUBz8eCujvu3gBsEk6XMpRsMNo
        32MloLPcivDbbPMCJn1RBY31aNZ6z-Dqnt4vQhot
        Y2JlyuF8.KJc0DvvcIivLA5uLYloF7HN9ovO14Sq
        6.F-NB-G4vBXs7evbBImex9x3foNi85Ca7wDb1c3
        tZmUsjVcZAGTajUOzsSNrr7a7BQVNSiA6xaiPEYf
        iCLMdAlduXvUtK1.awng0D0YP49kV8Cit7OLXyab
        7jJmsfrPpa2CeeYCAiByF3HW2J9.ARbc0adwEbWk
        &gt;&gt;&gt; reduce(add, a.components(0, 2, 7, additive=True)) + reduce(add, a.components(2, 3, 7, additive=True)) + reduce(add, a.components(3, 7, 7, additive=True)) == a
        True
        &gt;&gt;&gt; reduce(add, a.components(0, 7, 7, additive=True)) == a
        True
        &#34;&#34;&#34;
        if stop &gt; n:  # pragma: no cover
            raise Exception(f&#34;Wrong value:   stop=`{stop}`  &gt;=  n=`{n}`&#34;)
        acc = self.ø
        operator = add if additive else mul
        for i in range(0, stop):
            if stop == n and i == stop - 1:
                break
            if (t := (i, n, additive)) not in self._composition_memo:
                self._composition_memo[t] = Hosh(f&#34;{self.id}-{i}&#34;.encode(), version=self.version)
                if len(self._composition_memo) &gt; self.components_cache_size:  # pragma: no cover
                    first = next(iter(self._composition_memo))
                    del self._composition_memo[first]
            h = self._composition_memo[t]
            acc = operator(acc, h)
            if i &gt;= start:
                yield h
        if stop == n:
            inv = Hosh(cellsinv(acc.cells, self.p, additive), version=self.version)
            last = operator(inv, self)
            yield last

    def __getitem__(self, item: Union[int, tuple]):
        &#34;&#34;&#34;
        Reverse element:    Hosh(b&#34;blob&#34;)[-1]
        &#34;&#34;&#34;
        if item == -1:
            return self.rev
        if not isinstance(item, tuple) or len(item) != 2:  # pragma: no cover
            raise Exception(&#34;Wrong syntax, tuple or `-1` expected: hosh[-1] or hosh[i, n] or hosh[l:m, n]&#34;)
        slc, n = item
        if n &lt;= 0:  # pragma: no cover
            raise Exception(f&#34;Wrong value: n={n}  &lt;=  0&#34;)

        if isinstance(idx := slc, int):
            if idx &lt; n - 1:
                return Hosh(f&#34;{self.id}-{idx}&#34;.encode())
            if n == 1:
                return self
            if idx == n - 1:
                return list(self.components(0, n, n))[idx]
            raise Exception(f&#34;Wrong value: i={slc}  &gt;  n={n}&#34;)  # pragma: no cover

        if not isinstance(slc, slice) or slc.step is not None:  # pragma: no cover
            raise Exception(f&#34;Wrong syntax. Simple slice or index expected as first tuple item, not `{slc}`: hosh[i, n] or hosh[l:m, n]&#34;)

        if (start := slc.start) is None:
            start = 0
        if (stop := slc.stop) is None:
            stop = n

        if start &gt; n or start &lt; 0:  # pragma: no cover
            raise Exception(f&#34;Wrong values, expected: 0  &lt;=  i={start}  &lt;=  n={n}&#34;)
        if n == 1:
            return [self]
        return list(self.components(start, stop, n))

    @property
    def bits(self):
        &#34;&#34;&#34;
        &gt;&gt;&gt; from hosh import Hosh, groups
        &gt;&gt;&gt; Hosh(b&#34;asd&#34;).bits
        &#39;000110111101001001111010010101011100011010000011101010100000000001101101111101100111110100001011001001111001110110101101100110000000011111000110100100110011110010101110100011111101100010010111100111010101010011001110000001000100001101001111&#39;
        &gt;&gt;&gt; bits = Hosh.fromn(groups[40].p6 - 1).bits  # Max number.
        &gt;&gt;&gt; bits
        &#39;111111111111111111111111111111011111011000000000000000000000000110111011011111101111111111111111001101110000101001110100000000000011001100111000100101011110111011111001000010011000001000000100101101100110010011110110001000101011101110110000&#39;
        &gt;&gt;&gt; int(bits, 2) == groups[40].p6 - 1
        True
        &#34;&#34;&#34;
        if self._bits is None:
            self._bits = &#39;{:b}&#39;.format(self.n).rjust(self.digits * 6, &#34;0&#34;)
        return self._bits

    def __reduce__(self):
        return self.fromid, (self.id,)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="hosh.misc.identity.Identity" href="misc/identity.html#hosh.misc.identity.Identity">Identity</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="hosh.hosh_.Hosh.components_cache_size"><code class="name">var <span class="ident">components_cache_size</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="hosh.hosh_.Hosh.fromid"><code class="name flex">
<span>def <span class="ident">fromid</span></span>(<span>id)</span>
</code></dt>
<dd>
<div class="desc"><p>Create an element from a textual id.</p>
<p>Usage:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; a = Hosh.fromid(&quot;abcdefabcdefabcdefabcdefabcdefab&quot;)
&gt;&gt;&gt; a.n
1094566309952642687224764830259410933250743749332933330234
&gt;&gt;&gt; a.cells
(748932665, 516513868, 468764361, 3316970622, 2727293743, 316029245)
&gt;&gt;&gt; a.etype
'ordered'
&gt;&gt;&gt; bid = a.id[:2] + &quot;_&quot; + a.id[3:]
&gt;&gt;&gt; bid
'ab_defabcdefabcdefabcdefabcdefab'
&gt;&gt;&gt; b = Hosh.fromid(bid)
&gt;&gt;&gt; b.id
'ab_defabcdefabcdefabcdefabcdefab'
&gt;&gt;&gt; b.n
59377482839139050825606534576063885287
&gt;&gt;&gt; b.cells
(0, 0, 749449200, 1774140626, 3139018916, 292801225)
&gt;&gt;&gt; b.etype
'hybrid'
&gt;&gt;&gt; Hosh.fromid(&quot;0000000000000000000000000000000000000000000000000000000000000000&quot;) == 0
True
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>id</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="parameters_1">Parameters</h2>
<dl>
<dt><strong><code>id</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>A new <a title="hosh.hosh_.Hosh" href="#hosh.hosh_.Hosh">Hosh</a> object</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def fromid(cls, id):
    &#34;&#34;&#34;
    Create an element from a textual id.

    Usage:

    &gt;&gt;&gt; a = Hosh.fromid(&#34;abcdefabcdefabcdefabcdefabcdefab&#34;)
    &gt;&gt;&gt; a.n
    1094566309952642687224764830259410933250743749332933330234
    &gt;&gt;&gt; a.cells
    (748932665, 516513868, 468764361, 3316970622, 2727293743, 316029245)
    &gt;&gt;&gt; a.etype
    &#39;ordered&#39;
    &gt;&gt;&gt; bid = a.id[:2] + &#34;_&#34; + a.id[3:]
    &gt;&gt;&gt; bid
    &#39;ab_defabcdefabcdefabcdefabcdefab&#39;
    &gt;&gt;&gt; b = Hosh.fromid(bid)
    &gt;&gt;&gt; b.id
    &#39;ab_defabcdefabcdefabcdefabcdefab&#39;
    &gt;&gt;&gt; b.n
    59377482839139050825606534576063885287
    &gt;&gt;&gt; b.cells
    (0, 0, 749449200, 1774140626, 3139018916, 292801225)
    &gt;&gt;&gt; b.etype
    &#39;hybrid&#39;
    &gt;&gt;&gt; Hosh.fromid(&#34;0000000000000000000000000000000000000000000000000000000000000000&#34;) == 0
    True

    Parameters
    ----------
    id

    Parameters
    ----------
    id

    Returns
    -------
    A new Hosh object
    &#34;&#34;&#34;

    if len(id) not in groups:
        raise WrongIdentifier(f&#34;Wrong identifier length: {len(id)}   id:[{id}]&#34;)
    return Hosh(cells_fromid(id, p=groups[len(id)].p), version=groups[len(id)])</code></pre>
</details>
</dd>
<dt id="hosh.hosh_.Hosh.fromn"><code class="name flex">
<span>def <span class="ident">fromn</span></span>(<span>n: int, version=Group(p=1099511627689, p4=1461501636868331575725436266114840805196834679841, p6=1766847063939562670646036165286872353986524172769430561878277294118845361, digits=40, bytes=30, firstp='0_100000000_____________________________', lastp='f_8afffffff_____________________________', firstp4='00_1000000000000000000000000000000000000', lastp4='.._87c2a630003eec7dffff561b0000004aeffff', firstp6='1000000000000000000000000000000000000000', lastp6='g-8KOjCQREq2Vz8VTc30gLMd..vvX6000ov.....'))</span>
</code></dt>
<dd>
<div class="desc"><p>Create a Hosh object representing the given int.</p>
<p>Usage:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; h = Hosh.fromn(7647544756746324134134)
&gt;&gt;&gt; h.id
'00_e49c1c505dcd0039e91000000000000000000'
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>n</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>version</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>A new <a title="hosh.hosh_.Hosh" href="#hosh.hosh_.Hosh">Hosh</a> object</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def fromn(cls, n: int, version=UT40_4):
    &#34;&#34;&#34;
    Create a Hosh object representing the given int.

    Usage:

    &gt;&gt;&gt; h = Hosh.fromn(7647544756746324134134)
    &gt;&gt;&gt; h.id
    &#39;00_e49c1c505dcd0039e91000000000000000000&#39;

    Parameters
    ----------
    n
    version

    Returns
    -------
    A new Hosh object
    &#34;&#34;&#34;
    p, order = version.p, version.p6
    if n &gt; order:
        raise ElementTooHigh(f&#34;Element outside allowed range: {n} &gt;= {order}&#34;)
    return Hosh(int2cells(n, p), version=version)</code></pre>
</details>
</dd>
<dt id="hosh.hosh_.Hosh.fromtensor"><code class="name flex">
<span>def <span class="ident">fromtensor</span></span>(<span>tensor, device=None, version=Group(p=1099511627689, p4=1461501636868331575725436266114840805196834679841, p6=1766847063939562670646036165286872353986524172769430561878277294118845361, digits=40, bytes=30, firstp='0_100000000_____________________________', lastp='f_8afffffff_____________________________', firstp4='00_1000000000000000000000000000000000000', lastp4='.._87c2a630003eec7dffff561b0000004aeffff', firstp6='1000000000000000000000000000000000000000', lastp6='g-8KOjCQREq2Vz8VTc30gLMd..vvX6000ov.....'))</span>
</code></dt>
<dd>
<div class="desc"><p>Create a Hosh object representing the given tensor.</p>
<p>Vectorized pure-Torch implementation producing 6 ints from tensor T.
If <code>device</code> is provided and is a CUDA device, this can run on GPU.</p>
<p>Usage:
TODO: add example and generalize to other versions other than UT40_4 (need to adjust null case, multipliers, adds, and mod p)</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>tensor</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>device</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>version</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>A new <a title="hosh.hosh_.Hosh" href="#hosh.hosh_.Hosh">Hosh</a> object</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def fromtensor(cls, tensor, device=None, version=UT40_4):
    &#34;&#34;&#34;
    Create a Hosh object representing the given tensor.

    Vectorized pure-Torch implementation producing 6 ints from tensor T.
    If `device` is provided and is a CUDA device, this can run on GPU.

    Usage:
    TODO: add example and generalize to other versions other than UT40_4 (need to adjust null case, multipliers, adds, and mod p)

    Parameters
    ----------
    tensor
    device
    version

    Returns
    -------
    A new Hosh object
    &#34;&#34;&#34;
    if version != &#34;UT40_4&#34;:
        raise NotImplementedError(f&#34;Unsupported version: {version}&#34;)
    import torch
    arr = tensor.reshape(-1).to(torch.int64)
    if device is not None:
        arr = arr.to(device)
    if arr.numel() == 0:
        return Hosh([0] * 6, version=version)
    # 6 distinct multipliers/adds (int64) placed on the same device as arr
    mults = torch.tensor([1315423911, 2654435761, 97531, 1000003, 1000000007, 1610612741], dtype=torch.int64, device=arr.device).unsqueeze(1)
    adds = torch.tensor([2654435761, 97531, 1000003, 1000000007, 1610612741, 1315423911], dtype=torch.int64, device=arr.device).unsqueeze(1)
    mask64 = (1 &lt;&lt; 64) - 1
    mixed = arr.unsqueeze(0) * mults
    mixed = mixed + adds
    mixed = mixed ^ (mixed &gt;&gt; 23)
    sums = mixed.sum(dim=1)
    out = []
    for s in sums:
        s_int = int(s.item()) &amp; mask64
        out.append(int(s_int % version.p))
    return Hosh(out, version=version)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="hosh.hosh_.Hosh.ansi"><code class="name">var <span class="ident">ansi</span></code></dt>
<dd>
<div class="desc"><p>Colored textual (ANSI) representation of this element</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from hosh import Hosh
&gt;&gt;&gt; Hosh.fromid(&quot;Iaz3L67a2BQv0GifoWOjWale6LYFTGmJJ1ZPfdoP&quot;).ansi
'\x1b[38;5;229m\x1b[1m\x1b[48;5;0mI\x1b[0m\x1b[38;5;228m\x1b[1m\x1b[48;5;0ma\x1b[0m\x1b[38;5;222m\x1b[1m\x1b[48;5;0mz\x1b[0m\x1b[38;5;223m\x1b[1m\x1b[48;5;0m3\x1b[0m\x1b[38;5;228m\x1b[1m\x1b[48;5;0mL\x1b[0m\x1b[38;5;222m\x1b[1m\x1b[48;5;0m6\x1b[0m\x1b[38;5;222m\x1b[1m\x1b[48;5;0m7\x1b[0m\x1b[38;5;223m\x1b[1m\x1b[48;5;0ma\x1b[0m\x1b[38;5;228m\x1b[1m\x1b[48;5;0m2\x1b[0m\x1b[38;5;221m\x1b[1m\x1b[48;5;0mB\x1b[0m\x1b[38;5;216m\x1b[1m\x1b[48;5;0mQ\x1b[0m\x1b[38;5;186m\x1b[1m\x1b[48;5;0mv\x1b[0m\x1b[38;5;222m\x1b[1m\x1b[48;5;0m0\x1b[0m\x1b[38;5;221m\x1b[1m\x1b[48;5;0mG\x1b[0m\x1b[38;5;181m\x1b[1m\x1b[48;5;0mi\x1b[0m\x1b[38;5;194m\x1b[1m\x1b[48;5;0mf\x1b[0m\x1b[38;5;229m\x1b[1m\x1b[48;5;0mo\x1b[0m\x1b[38;5;228m\x1b[1m\x1b[48;5;0mW\x1b[0m\x1b[38;5;222m\x1b[1m\x1b[48;5;0mO\x1b[0m\x1b[38;5;223m\x1b[1m\x1b[48;5;0mj\x1b[0m\x1b[38;5;228m\x1b[1m\x1b[48;5;0mW\x1b[0m\x1b[38;5;222m\x1b[1m\x1b[48;5;0ma\x1b[0m\x1b[38;5;222m\x1b[1m\x1b[48;5;0ml\x1b[0m\x1b[38;5;223m\x1b[1m\x1b[48;5;0me\x1b[0m\x1b[38;5;228m\x1b[1m\x1b[48;5;0m6\x1b[0m\x1b[38;5;221m\x1b[1m\x1b[48;5;0mL\x1b[0m\x1b[38;5;216m\x1b[1m\x1b[48;5;0mY\x1b[0m\x1b[38;5;186m\x1b[1m\x1b[48;5;0mF\x1b[0m\x1b[38;5;222m\x1b[1m\x1b[48;5;0mT\x1b[0m\x1b[38;5;221m\x1b[1m\x1b[48;5;0mG\x1b[0m\x1b[38;5;181m\x1b[1m\x1b[48;5;0mm\x1b[0m\x1b[38;5;194m\x1b[1m\x1b[48;5;0mJ\x1b[0m\x1b[38;5;229m\x1b[1m\x1b[48;5;0mJ\x1b[0m\x1b[38;5;228m\x1b[1m\x1b[48;5;0m1\x1b[0m\x1b[38;5;222m\x1b[1m\x1b[48;5;0mZ\x1b[0m\x1b[38;5;223m\x1b[1m\x1b[48;5;0mP\x1b[0m\x1b[38;5;228m\x1b[1m\x1b[48;5;0mf\x1b[0m\x1b[38;5;222m\x1b[1m\x1b[48;5;0md\x1b[0m\x1b[38;5;222m\x1b[1m\x1b[48;5;0mo\x1b[0m\x1b[38;5;223m\x1b[1m\x1b[48;5;0mP\x1b[0m'
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Textual representation</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ansi(self):
    r&#34;&#34;&#34;
    Colored textual (ANSI) representation of this element

    &gt;&gt;&gt; from hosh import Hosh
    &gt;&gt;&gt; Hosh.fromid(&#34;Iaz3L67a2BQv0GifoWOjWale6LYFTGmJJ1ZPfdoP&#34;).ansi
    &#39;\x1b[38;5;229m\x1b[1m\x1b[48;5;0mI\x1b[0m\x1b[38;5;228m\x1b[1m\x1b[48;5;0ma\x1b[0m\x1b[38;5;222m\x1b[1m\x1b[48;5;0mz\x1b[0m\x1b[38;5;223m\x1b[1m\x1b[48;5;0m3\x1b[0m\x1b[38;5;228m\x1b[1m\x1b[48;5;0mL\x1b[0m\x1b[38;5;222m\x1b[1m\x1b[48;5;0m6\x1b[0m\x1b[38;5;222m\x1b[1m\x1b[48;5;0m7\x1b[0m\x1b[38;5;223m\x1b[1m\x1b[48;5;0ma\x1b[0m\x1b[38;5;228m\x1b[1m\x1b[48;5;0m2\x1b[0m\x1b[38;5;221m\x1b[1m\x1b[48;5;0mB\x1b[0m\x1b[38;5;216m\x1b[1m\x1b[48;5;0mQ\x1b[0m\x1b[38;5;186m\x1b[1m\x1b[48;5;0mv\x1b[0m\x1b[38;5;222m\x1b[1m\x1b[48;5;0m0\x1b[0m\x1b[38;5;221m\x1b[1m\x1b[48;5;0mG\x1b[0m\x1b[38;5;181m\x1b[1m\x1b[48;5;0mi\x1b[0m\x1b[38;5;194m\x1b[1m\x1b[48;5;0mf\x1b[0m\x1b[38;5;229m\x1b[1m\x1b[48;5;0mo\x1b[0m\x1b[38;5;228m\x1b[1m\x1b[48;5;0mW\x1b[0m\x1b[38;5;222m\x1b[1m\x1b[48;5;0mO\x1b[0m\x1b[38;5;223m\x1b[1m\x1b[48;5;0mj\x1b[0m\x1b[38;5;228m\x1b[1m\x1b[48;5;0mW\x1b[0m\x1b[38;5;222m\x1b[1m\x1b[48;5;0ma\x1b[0m\x1b[38;5;222m\x1b[1m\x1b[48;5;0ml\x1b[0m\x1b[38;5;223m\x1b[1m\x1b[48;5;0me\x1b[0m\x1b[38;5;228m\x1b[1m\x1b[48;5;0m6\x1b[0m\x1b[38;5;221m\x1b[1m\x1b[48;5;0mL\x1b[0m\x1b[38;5;216m\x1b[1m\x1b[48;5;0mY\x1b[0m\x1b[38;5;186m\x1b[1m\x1b[48;5;0mF\x1b[0m\x1b[38;5;222m\x1b[1m\x1b[48;5;0mT\x1b[0m\x1b[38;5;221m\x1b[1m\x1b[48;5;0mG\x1b[0m\x1b[38;5;181m\x1b[1m\x1b[48;5;0mm\x1b[0m\x1b[38;5;194m\x1b[1m\x1b[48;5;0mJ\x1b[0m\x1b[38;5;229m\x1b[1m\x1b[48;5;0mJ\x1b[0m\x1b[38;5;228m\x1b[1m\x1b[48;5;0m1\x1b[0m\x1b[38;5;222m\x1b[1m\x1b[48;5;0mZ\x1b[0m\x1b[38;5;223m\x1b[1m\x1b[48;5;0mP\x1b[0m\x1b[38;5;228m\x1b[1m\x1b[48;5;0mf\x1b[0m\x1b[38;5;222m\x1b[1m\x1b[48;5;0md\x1b[0m\x1b[38;5;222m\x1b[1m\x1b[48;5;0mo\x1b[0m\x1b[38;5;223m\x1b[1m\x1b[48;5;0mP\x1b[0m&#39;

    Returns
    -------
    Textual representation
    &#34;&#34;&#34;
    if self._ansi_light is None:
        self._ansi_light, self._ansi_dark = id2ansi(self.id)
    return self._ansi_dark if GLOBAL[&#34;dark_theme&#34;] else self._ansi_light</code></pre>
</details>
</dd>
<dt id="hosh.hosh_.Hosh.bits"><code class="name">var <span class="ident">bits</span></code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; from hosh import Hosh, groups
&gt;&gt;&gt; Hosh(b&quot;asd&quot;).bits
'000110111101001001111010010101011100011010000011101010100000000001101101111101100111110100001011001001111001110110101101100110000000011111000110100100110011110010101110100011111101100010010111100111010101010011001110000001000100001101001111'
&gt;&gt;&gt; bits = Hosh.fromn(groups[40].p6 - 1).bits  # Max number.
&gt;&gt;&gt; bits
'111111111111111111111111111111011111011000000000000000000000000110111011011111101111111111111111001101110000101001110100000000000011001100111000100101011110111011111001000010011000001000000100101101100110010011110110001000101011101110110000'
&gt;&gt;&gt; int(bits, 2) == groups[40].p6 - 1
True
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def bits(self):
    &#34;&#34;&#34;
    &gt;&gt;&gt; from hosh import Hosh, groups
    &gt;&gt;&gt; Hosh(b&#34;asd&#34;).bits
    &#39;000110111101001001111010010101011100011010000011101010100000000001101101111101100111110100001011001001111001110110101101100110000000011111000110100100110011110010101110100011111101100010010111100111010101010011001110000001000100001101001111&#39;
    &gt;&gt;&gt; bits = Hosh.fromn(groups[40].p6 - 1).bits  # Max number.
    &gt;&gt;&gt; bits
    &#39;111111111111111111111111111111011111011000000000000000000000000110111011011111101111111111111111001101110000101001110100000000000011001100111000100101011110111011111001000010011000001000000100101101100110010011110110001000101011101110110000&#39;
    &gt;&gt;&gt; int(bits, 2) == groups[40].p6 - 1
    True
    &#34;&#34;&#34;
    if self._bits is None:
        self._bits = &#39;{:b}&#39;.format(self.n).rjust(self.digits * 6, &#34;0&#34;)
    return self._bits</code></pre>
</details>
</dd>
<dt id="hosh.hosh_.Hosh.etype"><code class="name">var <span class="ident">etype</span></code></dt>
<dd>
<div class="desc"><p>Type of this element</p>
<p>Usage:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from hosh import Hosh
&gt;&gt;&gt; Hosh.fromn(5).etype
'unordered'
</code></pre>
<h2 id="returns">Returns</h2>
<p>'ordered', 'hybrid' or 'unordered'</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def etype(self):
    &#34;&#34;&#34;
    Type of this element

    Usage:

    &gt;&gt;&gt; from hosh import Hosh
    &gt;&gt;&gt; Hosh.fromn(5).etype
    &#39;unordered&#39;

    Returns
    -------
    &#39;ordered&#39;, &#39;hybrid&#39; or &#39;unordered&#39;
    &#34;&#34;&#34;
    if self._etype is None:
        if sum(self.cells[:5]) == 0:
            self._etype = &#34;unordered&#34;
        elif sum(self.cells[:2]) == 0:
            self._etype = &#34;hybrid&#34;
        else:
            self._etype = &#34;ordered&#34;
    return self._etype</code></pre>
</details>
</dd>
<dt id="hosh.hosh_.Hosh.etype_inducer"><code class="name">var <span class="ident">etype_inducer</span></code></dt>
<dd>
<div class="desc"><p>Type this element uses to coerce an element of undefined type.</p>
<p>Usage:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from hosh import ø, Hosh
&gt;&gt;&gt; ø.etype_inducer
'ordered'
&gt;&gt;&gt; ø.h.etype_inducer
'hybrid'
&gt;&gt;&gt; ø.u.etype_inducer
'unordered'
&gt;&gt;&gt; Hosh(b&quot;12124&quot;).etype_inducer
'ordered'
&gt;&gt;&gt; Hosh(b&quot;12124&quot;, etype=&quot;hybrid&quot;).etype_inducer
'hybrid'
</code></pre>
<h2 id="returns">Returns</h2>
<p>'ordered', 'hybrid', 'unordered'</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def etype_inducer(self):
    &#34;&#34;&#34;
    Type this element uses to coerce an element of undefined type.

    Usage:

    &gt;&gt;&gt; from hosh import ø, Hosh
    &gt;&gt;&gt; ø.etype_inducer
    &#39;ordered&#39;
    &gt;&gt;&gt; ø.h.etype_inducer
    &#39;hybrid&#39;
    &gt;&gt;&gt; ø.u.etype_inducer
    &#39;unordered&#39;
    &gt;&gt;&gt; Hosh(b&#34;12124&#34;).etype_inducer
    &#39;ordered&#39;
    &gt;&gt;&gt; Hosh(b&#34;12124&#34;, etype=&#34;hybrid&#34;).etype_inducer
    &#39;hybrid&#39;

    Returns
    -------
    &#39;ordered&#39;, &#39;hybrid&#39;, &#39;unordered&#39;
    &#34;&#34;&#34;
    if self._etype_inducer is None:
        self._etype_inducer = self.etype
    return self._etype_inducer</code></pre>
</details>
</dd>
<dt id="hosh.hosh_.Hosh.html"><code class="name">var <span class="ident">html</span></code></dt>
<dd>
<div class="desc"><p>HTML page containing a colored textual representation of this element</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Textual representation</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def html(self):
    &#34;&#34;&#34;
    HTML page containing a colored textual representation of this element

    Returns
    -------
    Textual representation
    &#34;&#34;&#34;
    return ansi2html(self.ansi)</code></pre>
</details>
</dd>
<dt id="hosh.hosh_.Hosh.id"><code class="name">var <span class="ident">id</span></code></dt>
<dd>
<div class="desc"><p>Textual representation of this element</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Textual representation</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def id(self):
    &#34;&#34;&#34;
    Textual representation of this element

    Returns
    -------
    Textual representation
    &#34;&#34;&#34;
    if self._id is None:
        self._id = id_fromcells(self.cells, self.digits, self.p)
    return self._id</code></pre>
</details>
</dd>
<dt id="hosh.hosh_.Hosh.idc"><code class="name">var <span class="ident">idc</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def idc(self):  # pragma: no cover
    print(&#34;&#39;hosh.idc&#39; is deprecated, use &#39;hosh.ansi&#39; instead&#34;)
    return self.ansi</code></pre>
</details>
</dd>
<dt id="hosh.hosh_.Hosh.n"><code class="name">var <span class="ident">n</span></code></dt>
<dd>
<div class="desc"><p>Lexicographic rank of this eloement (according to the format adopted in internal integer cells.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Number</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def n(self):
    &#34;&#34;&#34;
    Lexicographic rank of this eloement (according to the format adopted in internal integer cells.

    Returns
    -------
    Number
    &#34;&#34;&#34;
    if self._n is None:
        self._n = cells2int(self.cells, self.p)
    return self._n</code></pre>
</details>
</dd>
<dt id="hosh.hosh_.Hosh.rev"><code class="name">var <span class="ident">rev</span></code></dt>
<dd>
<div class="desc"><p>Reversed element (warning: this is not the inverse element)</p>
<p>Element with the internal cells reversed.
This operation is its own inverse.</p>
<p>This is useful wherever a unary operation is needed.
For instance, a function can be represented as a value by its original identifier,
and can be represented as (an applied) function by its reversed element identifier.</p>
<p>Not all hoshes are digest-reversible, i.e., at the digit level, due to the intrinsic mismatch between base 64 (i.e., a power of two) representation and the group (prime) order.
Therefore, we must resort to reversing the cells.
As an exception, unordered elements do have (most) digits reversed as it has only one internal cell.</p>
<p>Probabilistically irrelevant corner cases:
The presence of empty cells (i.e., with zero value) might cause migration from one etype to another.
The presence of duplicate cells (i.e., with the same value) might make the hosh reverse to itself.
See examples below.</p>
<p>Usage:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from hosh import Hosh, groups
&gt;&gt;&gt; h = Hosh.fromid(&quot;J5.uRTue8X4r1xu.JFkPbURVVGvTRPSFLncXdyzj&quot;).rev
&gt;&gt;&gt; h.id
'lUz6uu1ZBCJf342R7-qKOOqWJgaf3TDHx2M.CWGT'
&gt;&gt;&gt; h.rev.rev == h
True
&gt;&gt;&gt; h = Hosh.fromid(&quot;ab_cabcdefabcdefabcdefabcdefabcdefabcdef&quot;)
&gt;&gt;&gt; h.rev.id
'Hh_c7201818f76878562c52010943fe4f2a7f3b2'
&gt;&gt;&gt; h = Hosh.fromid(&quot;2_dbe78441d_____________________________&quot;)
&gt;&gt;&gt; h.rev.id
'2_dbd14487e_____________________________'
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; # Limits of subgroup Z.
&gt;&gt;&gt; Hosh.fromid(groups[40].firstp).id,  Hosh.fromid(groups[40].lastp).id
('0_100000000_____________________________', 'f_8afffffff_____________________________')
&gt;&gt;&gt; Hosh.fromid(groups[40].firstp).rev.id,  Hosh.fromid(groups[40].lastp).rev.id
('0_100000000_____________________________', 'f_8afffffff_____________________________')
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; # Limits of subgroup H.
&gt;&gt;&gt; Hosh.fromid(groups[40].firstp4).id, Hosh.fromid(groups[40].lastp4).id
('00_1000000000000000000000000000000000000', '.._87c2a630003eec7dffff561b0000004aeffff')
&gt;&gt;&gt; Hosh.fromid(groups[40].firstp4).rev.id, Hosh.fromid(groups[40].lastp4).rev.id
('00_9ed100000015ffffffff00000000000000000', '.._87c2a630003eec7dffff561b0000004aeffff')
&gt;&gt;&gt; Hosh.fromid(groups[40].firstp4).cells, Hosh.fromid(groups[40].lastp4).cells
((0, 0, 0, 0, 1, 0), (0, 0, 1099511627688, 1099511627688, 1099511627688, 1099511627688))
&gt;&gt;&gt; Hosh.fromid(groups[40].firstp4).rev.cells, Hosh.fromid(groups[40].lastp4).rev.cells
((0, 0, 0, 1, 0, 0), (0, 0, 1099511627688, 1099511627688, 1099511627688, 1099511627688))
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; # Limits of group G.
&gt;&gt;&gt; Hosh.fromid(groups[40].firstp6).id, Hosh.fromid(groups[40].lastp6).id
('1000000000000000000000000000000000000000', 'g-8KOjCQREq2Vz8VTc30gLMd..vvX6000ov.....')
&gt;&gt;&gt; Hosh.fromid(groups[40].firstp6).rev.id, Hosh.fromid(groups[40].lastp6).rev.id
('00_1000000000000000000000000000000000000', 'g-8KOjCQREq2Vz8VTc30gLMd..vvX6000ov.....')
&gt;&gt;&gt; Hosh.fromid(groups[40].firstp6).cells, Hosh.fromid(groups[40].lastp6).cells
((0, 1, 0, 0, 0, 0), (1099511627688, 1099511627688, 1099511627688, 1099511627688, 1099511627688, 1099511627688))
&gt;&gt;&gt; Hosh.fromid(groups[40].firstp6).rev.cells, Hosh.fromid(groups[40].lastp6).rev.cells
((0, 0, 0, 0, 1, 0), (1099511627688, 1099511627688, 1099511627688, 1099511627688, 1099511627688, 1099511627688))
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; # Near limits of group G.
&gt;&gt;&gt; Hosh.fromn(groups[40].p4+1).id, Hosh.fromn(groups[40].p6 - 2).id
('2000000000000000000000000000000000000000', 'f-8KOjCQREq2Vz8VTc30gLMd..vvX6000ov.....')
&gt;&gt;&gt; Hosh.fromn(groups[40].p4+1).rev.id, Hosh.fromn(groups[40].p6 - 2).rev.id
('ihdwjXvMdIj40gZQq-..5Ai0000j-....3000000', '7XoPrombpt9-UXQnse30Cgud..fcZ6000kv.....')
&gt;&gt;&gt; Hosh.fromn(groups[40].p4+1).cells, Hosh.fromn(groups[40].p6 - 2).cells
((0, 1, 0, 0, 0, 1), (1099511627688, 1099511627688, 1099511627688, 1099511627688, 1099511627688, 1099511627687))
&gt;&gt;&gt; Hosh.fromn(groups[40].p4+1).rev.cells, Hosh.fromn(groups[40].p6 - 2).rev.cells
((1, 0, 0, 0, 1, 0), (1099511627687, 1099511627688, 1099511627688, 1099511627688, 1099511627688, 1099511627688))
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def rev(self):
    &#34;&#34;&#34;
    Reversed element (warning: this is not the inverse element)

    Element with the internal cells reversed.
    This operation is its own inverse.

    This is useful wherever a unary operation is needed.
    For instance, a function can be represented as a value by its original identifier,
    and can be represented as (an applied) function by its reversed element identifier.

    Not all hoshes are digest-reversible, i.e., at the digit level, due to the intrinsic mismatch between base 64 (i.e., a power of two) representation and the group (prime) order.
    Therefore, we must resort to reversing the cells.
    As an exception, unordered elements do have (most) digits reversed as it has only one internal cell.

    Probabilistically irrelevant corner cases:
        The presence of empty cells (i.e., with zero value) might cause migration from one etype to another.
        The presence of duplicate cells (i.e., with the same value) might make the hosh reverse to itself.
        See examples below.

    Usage:

    &gt;&gt;&gt; from hosh import Hosh, groups
    &gt;&gt;&gt; h = Hosh.fromid(&#34;J5.uRTue8X4r1xu.JFkPbURVVGvTRPSFLncXdyzj&#34;).rev
    &gt;&gt;&gt; h.id
    &#39;lUz6uu1ZBCJf342R7-qKOOqWJgaf3TDHx2M.CWGT&#39;
    &gt;&gt;&gt; h.rev.rev == h
    True
    &gt;&gt;&gt; h = Hosh.fromid(&#34;ab_cabcdefabcdefabcdefabcdefabcdefabcdef&#34;)
    &gt;&gt;&gt; h.rev.id
    &#39;Hh_c7201818f76878562c52010943fe4f2a7f3b2&#39;
    &gt;&gt;&gt; h = Hosh.fromid(&#34;2_dbe78441d_____________________________&#34;)
    &gt;&gt;&gt; h.rev.id
    &#39;2_dbd14487e_____________________________&#39;

    &gt;&gt;&gt; # Limits of subgroup Z.
    &gt;&gt;&gt; Hosh.fromid(groups[40].firstp).id,  Hosh.fromid(groups[40].lastp).id
    (&#39;0_100000000_____________________________&#39;, &#39;f_8afffffff_____________________________&#39;)
    &gt;&gt;&gt; Hosh.fromid(groups[40].firstp).rev.id,  Hosh.fromid(groups[40].lastp).rev.id
    (&#39;0_100000000_____________________________&#39;, &#39;f_8afffffff_____________________________&#39;)

    &gt;&gt;&gt; # Limits of subgroup H.
    &gt;&gt;&gt; Hosh.fromid(groups[40].firstp4).id, Hosh.fromid(groups[40].lastp4).id
    (&#39;00_1000000000000000000000000000000000000&#39;, &#39;.._87c2a630003eec7dffff561b0000004aeffff&#39;)
    &gt;&gt;&gt; Hosh.fromid(groups[40].firstp4).rev.id, Hosh.fromid(groups[40].lastp4).rev.id
    (&#39;00_9ed100000015ffffffff00000000000000000&#39;, &#39;.._87c2a630003eec7dffff561b0000004aeffff&#39;)
    &gt;&gt;&gt; Hosh.fromid(groups[40].firstp4).cells, Hosh.fromid(groups[40].lastp4).cells
    ((0, 0, 0, 0, 1, 0), (0, 0, 1099511627688, 1099511627688, 1099511627688, 1099511627688))
    &gt;&gt;&gt; Hosh.fromid(groups[40].firstp4).rev.cells, Hosh.fromid(groups[40].lastp4).rev.cells
    ((0, 0, 0, 1, 0, 0), (0, 0, 1099511627688, 1099511627688, 1099511627688, 1099511627688))

    &gt;&gt;&gt; # Limits of group G.
    &gt;&gt;&gt; Hosh.fromid(groups[40].firstp6).id, Hosh.fromid(groups[40].lastp6).id
    (&#39;1000000000000000000000000000000000000000&#39;, &#39;g-8KOjCQREq2Vz8VTc30gLMd..vvX6000ov.....&#39;)
    &gt;&gt;&gt; Hosh.fromid(groups[40].firstp6).rev.id, Hosh.fromid(groups[40].lastp6).rev.id
    (&#39;00_1000000000000000000000000000000000000&#39;, &#39;g-8KOjCQREq2Vz8VTc30gLMd..vvX6000ov.....&#39;)
    &gt;&gt;&gt; Hosh.fromid(groups[40].firstp6).cells, Hosh.fromid(groups[40].lastp6).cells
    ((0, 1, 0, 0, 0, 0), (1099511627688, 1099511627688, 1099511627688, 1099511627688, 1099511627688, 1099511627688))
    &gt;&gt;&gt; Hosh.fromid(groups[40].firstp6).rev.cells, Hosh.fromid(groups[40].lastp6).rev.cells
    ((0, 0, 0, 0, 1, 0), (1099511627688, 1099511627688, 1099511627688, 1099511627688, 1099511627688, 1099511627688))

    &gt;&gt;&gt; # Near limits of group G.
    &gt;&gt;&gt; Hosh.fromn(groups[40].p4+1).id, Hosh.fromn(groups[40].p6 - 2).id
    (&#39;2000000000000000000000000000000000000000&#39;, &#39;f-8KOjCQREq2Vz8VTc30gLMd..vvX6000ov.....&#39;)
    &gt;&gt;&gt; Hosh.fromn(groups[40].p4+1).rev.id, Hosh.fromn(groups[40].p6 - 2).rev.id
    (&#39;ihdwjXvMdIj40gZQq-..5Ai0000j-....3000000&#39;, &#39;7XoPrombpt9-UXQnse30Cgud..fcZ6000kv.....&#39;)
    &gt;&gt;&gt; Hosh.fromn(groups[40].p4+1).cells, Hosh.fromn(groups[40].p6 - 2).cells
    ((0, 1, 0, 0, 0, 1), (1099511627688, 1099511627688, 1099511627688, 1099511627688, 1099511627688, 1099511627687))
    &gt;&gt;&gt; Hosh.fromn(groups[40].p4+1).rev.cells, Hosh.fromn(groups[40].p6 - 2).rev.cells
    ((1, 0, 0, 0, 1, 0), (1099511627687, 1099511627688, 1099511627688, 1099511627688, 1099511627688, 1099511627688))
    &#34;&#34;&#34;
    if self._rev is None:
        id = self.id
        if self.etype == &#34;ordered&#34;:
            self._rev = Hosh(tuple(reversed(self.cells)))
        elif self.etype == &#34;hybrid&#34;:
            self._rev = Hosh(self.cells[:2] + tuple(reversed(self.cells[2:])))
        elif self.etype == &#34;unordered&#34;:
            self._rev = Hosh.fromid(id[:4] + &#34;&#34;.join(reversed(id[4:11])) + &#34;_____________________________&#34;)
        else:  # pragma: no cover
            raise Exception(f&#34;Unexpected condition. element type: {self.etype}&#34;)
    return self._rev</code></pre>
</details>
</dd>
<dt id="hosh.hosh_.Hosh.rgb"><code class="name">var <span class="ident">rgb</span></code></dt>
<dd>
<div class="desc"><p>Colored textual (RGB) representation of this element</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from hosh import Hosh
&gt;&gt;&gt; Hosh.fromid(&quot;Iaz3L67a2BQv0GifoWOjWale6LYFTGmJJ1ZPfdoP&quot;).rgb
[[6, 28, 104], [255, 255, 184], [255, 255, 141], [255, 220, 155], [255, 233, 172], [255, 250, 139], [255, 218, 144], [254, 223, 150], [255, 229, 187], [255, 255, 127], [255, 206, 98], [242, 176, 123], [212, 201, 138], [237, 216, 120], [252, 198, 115], [234, 193, 174], [229, 253, 204], [255, 255, 184], [255, 255, 141], [255, 220, 155], [255, 233, 172], [255, 250, 139], [255, 218, 144], [254, 223, 150], [255, 229, 187], [255, 255, 127], [255, 206, 98], [242, 176, 123], [212, 201, 138], [237, 216, 120], [252, 198, 115], [234, 193, 174], [229, 253, 204], [255, 255, 184], [255, 255, 141], [255, 220, 155], [255, 233, 172], [255, 250, 139], [255, 218, 144], [254, 223, 150], [255, 229, 187]]
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def rgb(self):
    &#34;&#34;&#34;
    Colored textual (RGB) representation of this element

    &gt;&gt;&gt; from hosh import Hosh
    &gt;&gt;&gt; Hosh.fromid(&#34;Iaz3L67a2BQv0GifoWOjWale6LYFTGmJJ1ZPfdoP&#34;).rgb
    [[6, 28, 104], [255, 255, 184], [255, 255, 141], [255, 220, 155], [255, 233, 172], [255, 250, 139], [255, 218, 144], [254, 223, 150], [255, 229, 187], [255, 255, 127], [255, 206, 98], [242, 176, 123], [212, 201, 138], [237, 216, 120], [252, 198, 115], [234, 193, 174], [229, 253, 204], [255, 255, 184], [255, 255, 141], [255, 220, 155], [255, 233, 172], [255, 250, 139], [255, 218, 144], [254, 223, 150], [255, 229, 187], [255, 255, 127], [255, 206, 98], [242, 176, 123], [212, 201, 138], [237, 216, 120], [252, 198, 115], [234, 193, 174], [229, 253, 204], [255, 255, 184], [255, 255, 141], [255, 220, 155], [255, 233, 172], [255, 250, 139], [255, 218, 144], [254, 223, 150], [255, 229, 187]]
    &#34;&#34;&#34;
    if self._rgb_light is None:
        self._rgb_light, self._rgb_dark = id2rgb(self.id)
    return self._rgb_dark if GLOBAL[&#34;dark_theme&#34;] else self._rgb_light</code></pre>
</details>
</dd>
<dt id="hosh.hosh_.Hosh.sansi"><code class="name">var <span class="ident">sansi</span></code></dt>
<dd>
<div class="desc"><p>Shorter colored id (base-777 using up to 2 bytes utf8 per char)</p>
<p>Usage:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from hosh import ø
&gt;&gt;&gt; print((ø * b'65e987978g').sansi)
[38;5;156m[1m[48;5;0mȟ[0m[38;5;155m[1m[48;5;0mɟ[0m[38;5;185m[1m[48;5;0mì[0m[38;5;113m[1m[48;5;0mӧ[0m[38;5;119m[1m[48;5;0mД[0m[38;5;185m[1m[48;5;0mɫ[0m[38;5;113m[1m[48;5;0mŖ[0m[38;5;119m[1m[48;5;0mā[0m[38;5;149m[1m[48;5;0mö[0m[38;5;113m[1m[48;5;0mơ[0m[38;5;83m[1m[48;5;0mɟ[0m[38;5;155m[1m[48;5;0mբ[0m[38;5;149m[1m[48;5;0mƢ[0m[38;5;119m[1m[48;5;0mŊ[0m[38;5;185m[1m[48;5;0mþ[0m[38;5;119m[1m[48;5;0mX[0m[38;5;156m[1m[48;5;0mÊ[0m[38;5;155m[1m[48;5;0mϱ[0m[38;5;185m[1m[48;5;0mՎ[0m[38;5;113m[1m[48;5;0mҲ[0m[38;5;119m[1m[48;5;0mģ[0m[38;5;185m[1m[48;5;0mţ[0m[38;5;113m[1m[48;5;0mՀ[0m[38;5;119m[1m[48;5;0mɄ[0m[38;5;149m[1m[48;5;0mЌ[0m
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Short utf-8 colored textual representation</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def sansi(self):
    &#34;&#34;&#34;
    Shorter colored id (base-777 using up to 2 bytes utf8 per char)

    Usage:

    &gt;&gt;&gt; from hosh import ø
    &gt;&gt;&gt; print((ø * b&#39;65e987978g&#39;).sansi)
    \x1b[38;5;156m\x1b[1m\x1b[48;5;0mȟ\x1b[0m\x1b[38;5;155m\x1b[1m\x1b[48;5;0mɟ\x1b[0m\x1b[38;5;185m\x1b[1m\x1b[48;5;0mì\x1b[0m\x1b[38;5;113m\x1b[1m\x1b[48;5;0mӧ\x1b[0m\x1b[38;5;119m\x1b[1m\x1b[48;5;0mД\x1b[0m\x1b[38;5;185m\x1b[1m\x1b[48;5;0mɫ\x1b[0m\x1b[38;5;113m\x1b[1m\x1b[48;5;0mŖ\x1b[0m\x1b[38;5;119m\x1b[1m\x1b[48;5;0mā\x1b[0m\x1b[38;5;149m\x1b[1m\x1b[48;5;0mö\x1b[0m\x1b[38;5;113m\x1b[1m\x1b[48;5;0mơ\x1b[0m\x1b[38;5;83m\x1b[1m\x1b[48;5;0mɟ\x1b[0m\x1b[38;5;155m\x1b[1m\x1b[48;5;0mբ\x1b[0m\x1b[38;5;149m\x1b[1m\x1b[48;5;0mƢ\x1b[0m\x1b[38;5;119m\x1b[1m\x1b[48;5;0mŊ\x1b[0m\x1b[38;5;185m\x1b[1m\x1b[48;5;0mþ\x1b[0m\x1b[38;5;119m\x1b[1m\x1b[48;5;0mX\x1b[0m\x1b[38;5;156m\x1b[1m\x1b[48;5;0mÊ\x1b[0m\x1b[38;5;155m\x1b[1m\x1b[48;5;0mϱ\x1b[0m\x1b[38;5;185m\x1b[1m\x1b[48;5;0mՎ\x1b[0m\x1b[38;5;113m\x1b[1m\x1b[48;5;0mҲ\x1b[0m\x1b[38;5;119m\x1b[1m\x1b[48;5;0mģ\x1b[0m\x1b[38;5;185m\x1b[1m\x1b[48;5;0mţ\x1b[0m\x1b[38;5;113m\x1b[1m\x1b[48;5;0mՀ\x1b[0m\x1b[38;5;119m\x1b[1m\x1b[48;5;0mɄ\x1b[0m\x1b[38;5;149m\x1b[1m\x1b[48;5;0mЌ\x1b[0m

    Returns
    -------
    Short utf-8 colored textual representation
    &#34;&#34;&#34;
    if self._sansi_light is None:
        self._sansi_light, self._sansi_dark = id2ansi(self.sid)
    return self._sansi_dark if GLOBAL[&#34;dark_theme&#34;] else self._sansi_light</code></pre>
</details>
</dd>
<dt id="hosh.hosh_.Hosh.shtml"><code class="name">var <span class="ident">shtml</span></code></dt>
<dd>
<div class="desc"><p>Short colored html digest</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def shtml(self):
    &#34;&#34;&#34;Short colored html digest&#34;&#34;&#34;
    return ansi2html(self.sansi)</code></pre>
</details>
</dd>
<dt id="hosh.hosh_.Hosh.sid"><code class="name">var <span class="ident">sid</span></code></dt>
<dd>
<div class="desc"><p>Shorter id (base-777 using up to 2 bytes utf8 per char)</p>
<p>Usage:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from hosh import ø
&gt;&gt;&gt; (ø * b'65e987978g').sid
'ȟɟìӧДɫŖāöơɟբƢŊþXÊϱՎҲģţՀɄЌ'
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Short utf-8 textual representation</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def sid(self):
    &#34;&#34;&#34;
    Shorter id (base-777 using up to 2 bytes utf8 per char)

    Usage:

    &gt;&gt;&gt; from hosh import ø
    &gt;&gt;&gt; (ø * b&#39;65e987978g&#39;).sid
    &#39;ȟɟìӧДɫŖāöơɟբƢŊþXÊϱՎҲģţՀɄЌ&#39;

    Returns
    -------
    Short utf-8 textual representation
    &#34;&#34;&#34;
    if self._sid is None:
        self._sid = b777enc(self.n, self.digits * 5 // 8)
    return self._sid</code></pre>
</details>
</dd>
<dt id="hosh.hosh_.Hosh.sidc"><code class="name">var <span class="ident">sidc</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def sidc(self):  # pragma: no cover
    print(&#34;&#39;hosh.sidc&#39; is deprecated, please use &#39;hosh.sansi&#39; instead&#34;)
    return self.sansi</code></pre>
</details>
</dd>
<dt id="hosh.hosh_.Hosh.ø"><code class="name">var <span class="ident">ø</span></code></dt>
<dd>
<div class="desc"><p>Identity element compatible with this Hosh object</p>
<p>Usage:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from hosh import Hosh
&gt;&gt;&gt; (b := Hosh(b&quot;23987rg23&quot;)).id
'J5.uRTue8X4r1xu.JFkPbURVVGvTRPSFLncXdyzj'
&gt;&gt;&gt; b.etype
'ordered'
&gt;&gt;&gt; b.ø.etype
'unordered'
&gt;&gt;&gt; b.etype == b.ø.etype_inducer
True
&gt;&gt;&gt; b.ø.id
'0000000000000000000000000000000000000000'
&gt;&gt;&gt; (b.ø * b&quot;qwer&quot;).etype
'ordered'
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ø(self):
    &#34;&#34;&#34;Identity element compatible with this Hosh object

    Usage:

    &gt;&gt;&gt; from hosh import Hosh
    &gt;&gt;&gt; (b := Hosh(b&#34;23987rg23&#34;)).id
    &#39;J5.uRTue8X4r1xu.JFkPbURVVGvTRPSFLncXdyzj&#39;
    &gt;&gt;&gt; b.etype
    &#39;ordered&#39;
    &gt;&gt;&gt; b.ø.etype
    &#39;unordered&#39;
    &gt;&gt;&gt; b.etype == b.ø.etype_inducer
    True
    &gt;&gt;&gt; b.ø.id
    &#39;0000000000000000000000000000000000000000&#39;
    &gt;&gt;&gt; (b.ø * b&#34;qwer&#34;).etype
    &#39;ordered&#39;
    &#34;&#34;&#34;
    if self._ø is None:
        from hosh import Identity

        self._ø = Identity(version=self.version, etype_inducer=self.etype)
    return self._ø</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="hosh.hosh_.Hosh.bad_additive_component"><code class="name flex">
<span>def <span class="ident">bad_additive_component</span></span>(<span>self, i, n)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the <code>i</code>-th additive component for <code>x</code> such that <code>x = x1 + x2 + ... + xn</code></p>
<p>See <code>bad_additive_components</code> for more details.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from functools import reduce
&gt;&gt;&gt; import operator
&gt;&gt;&gt; list(Hosh(b&quot;x&quot;).bad_additive_components(2))[0] == Hosh(b&quot;x&quot;).bad_additive_component(0, 2)
True
&gt;&gt;&gt; list(Hosh(b&quot;x&quot;).bad_additive_components(2))[1] == Hosh(b&quot;x&quot;).bad_additive_component(1, 2)
True
&gt;&gt;&gt; list(Hosh(b&quot;x&quot;).bad_additive_components(3))[0] == Hosh(b&quot;x&quot;).bad_additive_component(0, 3)
True
&gt;&gt;&gt; list(Hosh(b&quot;x&quot;).bad_additive_components(3))[1] == Hosh(b&quot;x&quot;).bad_additive_component(1, 3)
True
&gt;&gt;&gt; list(Hosh(b&quot;x&quot;).bad_additive_components(3))[2] == Hosh(b&quot;x&quot;).bad_additive_component(2, 3)
True
&gt;&gt;&gt; list(Hosh(b&quot;x&quot;).bad_additive_components(5))[0] == Hosh(b&quot;x&quot;).bad_additive_component(0, 5)
True
&gt;&gt;&gt; list(Hosh(b&quot;x&quot;).bad_additive_components(5))[1] == Hosh(b&quot;x&quot;).bad_additive_component(1, 5)
True
&gt;&gt;&gt; list(Hosh(b&quot;x&quot;).bad_additive_components(5))[2] == Hosh(b&quot;x&quot;).bad_additive_component(2, 5)
True
&gt;&gt;&gt; list(Hosh(b&quot;x&quot;).bad_additive_components(5))[4] == Hosh(b&quot;x&quot;).bad_additive_component(4, 5)
True
&gt;&gt;&gt; list(Hosh(b&quot;x&quot;).bad_additive_components(7))[0] == Hosh(b&quot;x&quot;).bad_additive_component(0, 7)
True
&gt;&gt;&gt; list(Hosh(b&quot;x&quot;).bad_additive_components(7))[1] == Hosh(b&quot;x&quot;).bad_additive_component(1, 7)
True
&gt;&gt;&gt; list(Hosh(b&quot;x&quot;).bad_additive_components(7))[2] == Hosh(b&quot;x&quot;).bad_additive_component(2, 7)
True
&gt;&gt;&gt; list(Hosh(b&quot;x&quot;).bad_additive_components(7))[4] == Hosh(b&quot;x&quot;).bad_additive_component(4, 7)
True
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bad_additive_component(self, i, n):
    &#34;&#34;&#34;
    Return the `i`-th additive component for `x` such that `x = x1 + x2 + ... + xn`

    See `bad_additive_components` for more details.

    &gt;&gt;&gt; from functools import reduce
    &gt;&gt;&gt; import operator
    &gt;&gt;&gt; list(Hosh(b&#34;x&#34;).bad_additive_components(2))[0] == Hosh(b&#34;x&#34;).bad_additive_component(0, 2)
    True
    &gt;&gt;&gt; list(Hosh(b&#34;x&#34;).bad_additive_components(2))[1] == Hosh(b&#34;x&#34;).bad_additive_component(1, 2)
    True
    &gt;&gt;&gt; list(Hosh(b&#34;x&#34;).bad_additive_components(3))[0] == Hosh(b&#34;x&#34;).bad_additive_component(0, 3)
    True
    &gt;&gt;&gt; list(Hosh(b&#34;x&#34;).bad_additive_components(3))[1] == Hosh(b&#34;x&#34;).bad_additive_component(1, 3)
    True
    &gt;&gt;&gt; list(Hosh(b&#34;x&#34;).bad_additive_components(3))[2] == Hosh(b&#34;x&#34;).bad_additive_component(2, 3)
    True
    &gt;&gt;&gt; list(Hosh(b&#34;x&#34;).bad_additive_components(5))[0] == Hosh(b&#34;x&#34;).bad_additive_component(0, 5)
    True
    &gt;&gt;&gt; list(Hosh(b&#34;x&#34;).bad_additive_components(5))[1] == Hosh(b&#34;x&#34;).bad_additive_component(1, 5)
    True
    &gt;&gt;&gt; list(Hosh(b&#34;x&#34;).bad_additive_components(5))[2] == Hosh(b&#34;x&#34;).bad_additive_component(2, 5)
    True
    &gt;&gt;&gt; list(Hosh(b&#34;x&#34;).bad_additive_components(5))[4] == Hosh(b&#34;x&#34;).bad_additive_component(4, 5)
    True
    &gt;&gt;&gt; list(Hosh(b&#34;x&#34;).bad_additive_components(7))[0] == Hosh(b&#34;x&#34;).bad_additive_component(0, 7)
    True
    &gt;&gt;&gt; list(Hosh(b&#34;x&#34;).bad_additive_components(7))[1] == Hosh(b&#34;x&#34;).bad_additive_component(1, 7)
    True
    &gt;&gt;&gt; list(Hosh(b&#34;x&#34;).bad_additive_components(7))[2] == Hosh(b&#34;x&#34;).bad_additive_component(2, 7)
    True
    &gt;&gt;&gt; list(Hosh(b&#34;x&#34;).bad_additive_components(7))[4] == Hosh(b&#34;x&#34;).bad_additive_component(4, 7)
    True
    &#34;&#34;&#34;
    den = n * (n + 1) // 2
    p = self.p
    i += 1
    toggle = 1 if i == n else 0

    def fac(x):
        parc, rem = divmod(x + p, den)
        return (i * parc + toggle * rem) % p

    return Hosh(tuple(fac(c) for c in self.cells), version=self.version)</code></pre>
</details>
</dd>
<dt id="hosh.hosh_.Hosh.bad_additive_components"><code class="name flex">
<span>def <span class="ident">bad_additive_components</span></span>(<span>self, n)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the <code>n</code> additive components for <code>x</code> such that <code>x = x1 + x2 + ... + xn</code></p>
<p><code>xn</code> fills the gap left by the other components remainder.
We do not recommend this "decomposition" as it always generates different ids for the same subvalue.
For instance,
if a list <code>[value1, value2, value3]</code> induces ids <code>a</code>, <code>b</code>, and <code>any</code>,
another list <code>[value1, value2, &hellip;]</code> necessarily induces <code>c</code> and <code>d</code> as first two ids such that <code>a != c</code> and <code>b != d</code>.</p>
<h1 id="parameters">Parameters</h1>
<p>n
Desired total number of components</p>
<h1 id="returns">Returns</h1>
<pre><code>Generator of hoshes
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; from functools import reduce
&gt;&gt;&gt; import operator
&gt;&gt;&gt; reduce(operator.add, Hosh(b&quot;x&quot;).bad_additive_components(5)) == Hosh(b&quot;x&quot;)
True
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bad_additive_components(self, n):
    &#34;&#34;&#34;
    Return the `n` additive components for `x` such that `x = x1 + x2 + ... + xn`

    `xn` fills the gap left by the other components remainder.
    We do not recommend this &#34;decomposition&#34; as it always generates different ids for the same subvalue.
    For instance,
        if a list `[value1, value2, value3]` induces ids `a`, `b`, and `any`,
         another list `[value1, value2, ...]` necessarily induces `c` and `d` as first two ids such that `a != c` and `b != d`.

    Parameters
    ==========
    n
        Desired total number of components

    Returns
    =======
        Generator of hoshes

    &gt;&gt;&gt; from functools import reduce
    &gt;&gt;&gt; import operator
    &gt;&gt;&gt; reduce(operator.add, Hosh(b&#34;x&#34;).bad_additive_components(5)) == Hosh(b&#34;x&#34;)
    True
    &#34;&#34;&#34;
    den = n * (n + 1) // 2
    p = self.p

    def fac(x):
        parc, rem = divmod(x + p, den)
        lst = [i * parc for i in range(1, n + 1)]
        lst[-1] += rem
        return [l % p for l in lst]

    return (Hosh(tuple(x), version=self.version) for x in zip(*(fac(c) for c in self.cells)))</code></pre>
</details>
</dd>
<dt id="hosh.hosh_.Hosh.components"><code class="name flex">
<span>def <span class="ident">components</span></span>(<span>self, start, stop, n, additive=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Pseudo"decomposition" based on the hosh of the current id concatenated as bytes to a given component index</p>
<p>Perform a multiplicative decomposition by default.</p>
<h2 id="syntax">Syntax</h2>
<p>Hosh(b"blob").components(i, m, n)
# Takes a slice of elements.
Hosh(b"blob")[i:m, n]
# Takes a slice of elements.
Hosh(b"blob")[i, n]
# Takes element <code>i</code> out of <code>n</code> components.
Hosh(b"blob")[:n, n]
# All <code>n</code> elements.</p>
<h2 id="warning">Warning</h2>
<p>Hosh(b"blob")[-1]
# Reverse element. Not to be confused with inverse element.</p>
<p>The components are arbitrarily internally defined group elements based on current id as hashed bytes:
Hosh(id+"-1"), Hosh(id+"-2"), &hellip;, Hosh(id+"-n")</p>
<p>The last element (xn) is the exception as it makes the product x1 * x2 * &hellip; * xn match x:
x1
= id+"-1" * x
&hellip;
xn-1
= id+"-n-1" * x
xn
= (id+"-1" * x * &hellip; * id+"-n-1")-¹</p>
<h1 id="parameters">Parameters</h1>
<p>start
Start of a slice
stop
Stop of a slice
n
Desired total number of components
additive
Set up an additive decomposition</p>
<h1 id="returns">Returns</h1>
<pre><code>List if hoshes
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; from hosh import Hosh
&gt;&gt;&gt; a = Hosh(b&quot;a&quot;)
&gt;&gt;&gt; a[-1].rev == a
True
&gt;&gt;&gt; a[0, 1] == a
True
&gt;&gt;&gt; a[0:, 1][0] == a
True
&gt;&gt;&gt; a[:1, 1][0] == a
True
&gt;&gt;&gt; a[0:1, 1][0] == a
True
&gt;&gt;&gt; from operator import mul
&gt;&gt;&gt; reduce(mul, a[:, 3]) == a
True
&gt;&gt;&gt; [x.id for x in a[:, 3]]
['Bd6Axil5pFSp15HUBz8eCujvu3gBsEk6XMpRsMNo', '32MloLPcivDbbPMCJn1RBY31aNZ6z-Dqnt4vQhot', 'la3xnZmlhn3lFBAnvWw-UWAvK.2hk-QqUNFYAs3e']
&gt;&gt;&gt; a[:, 3][0] * a[:, 3][1] * a[:, 3][2] == a
True
&gt;&gt;&gt; a[0, 3] * a[1, 3] * a[2, 3] == a
True
&gt;&gt;&gt; a.id
'cIXBKPediDiOKabeZ6SthD04rnzaquNXaAEhSud4'
&gt;&gt;&gt; from operator import add, mul
&gt;&gt;&gt; from functools import reduce
&gt;&gt;&gt; print(&quot;\n&quot;.join(x.id for x in a.components(0, 7, 7)))
Bd6Axil5pFSp15HUBz8eCujvu3gBsEk6XMpRsMNo
32MloLPcivDbbPMCJn1RBY31aNZ6z-Dqnt4vQhot
Y2JlyuF8.KJc0DvvcIivLA5uLYloF7HN9ovO14Sq
6.F-NB-G4vBXs7evbBImex9x3foNi85Ca7wDb1c3
tZmUsjVcZAGTajUOzsSNrr7a7BQVNSiA6xaiPEYf
iCLMdAlduXvUtK1.awng0D0YP49kV8Cit7OLXyab
BA6UvITsIN822llT9eErc1R0rmf.ARbc0adwEbWk
&gt;&gt;&gt; reduce(mul, a.components(0, 2, 7)) * reduce(mul, a.components(2, 3, 7)) * reduce(mul, a.components(3, 7, 7)) == a
True
&gt;&gt;&gt; reduce(mul, a.components(0, 7, 7)) == a
True
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; print(&quot;\n&quot;.join(x.id for x in a.components(0, 7, 7, additive=True)))
Bd6Axil5pFSp15HUBz8eCujvu3gBsEk6XMpRsMNo
32MloLPcivDbbPMCJn1RBY31aNZ6z-Dqnt4vQhot
Y2JlyuF8.KJc0DvvcIivLA5uLYloF7HN9ovO14Sq
6.F-NB-G4vBXs7evbBImex9x3foNi85Ca7wDb1c3
tZmUsjVcZAGTajUOzsSNrr7a7BQVNSiA6xaiPEYf
iCLMdAlduXvUtK1.awng0D0YP49kV8Cit7OLXyab
7jJmsfrPpa2CeeYCAiByF3HW2J9.ARbc0adwEbWk
&gt;&gt;&gt; reduce(add, a.components(0, 2, 7, additive=True)) + reduce(add, a.components(2, 3, 7, additive=True)) + reduce(add, a.components(3, 7, 7, additive=True)) == a
True
&gt;&gt;&gt; reduce(add, a.components(0, 7, 7, additive=True)) == a
True
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def components(self, start, stop, n, additive=False):
    r&#34;&#34;&#34;
    Pseudo&#34;decomposition&#34; based on the hosh of the current id concatenated as bytes to a given component index

    Perform a multiplicative decomposition by default.

    Syntax:
        Hosh(b&#34;blob&#34;).components(i, m, n)   # Takes a slice of elements.
        Hosh(b&#34;blob&#34;)[i:m, n]               # Takes a slice of elements.
        Hosh(b&#34;blob&#34;)[i, n]                 # Takes element `i` out of `n` components.
        Hosh(b&#34;blob&#34;)[:n, n]                # All `n` elements.
    Warning:
        Hosh(b&#34;blob&#34;)[-1]                   # Reverse element. Not to be confused with inverse element.


    The components are arbitrarily internally defined group elements based on current id as hashed bytes:
    Hosh(id+&#34;-1&#34;), Hosh(id+&#34;-2&#34;), ..., Hosh(id+&#34;-n&#34;)

    The last element (xn) is the exception as it makes the product x1 * x2 * ... * xn match x:
    x1      = id+&#34;-1&#34; * x
     ...
    xn-1    = id+&#34;-n-1&#34; * x
    xn      = (id+&#34;-1&#34; * x * ... * id+&#34;-n-1&#34;)-¹

    Parameters
    ==========
    start
        Start of a slice
    stop
        Stop of a slice
    n
        Desired total number of components
    additive
        Set up an additive decomposition

    Returns
    =======
        List if hoshes

    &gt;&gt;&gt; from hosh import Hosh
    &gt;&gt;&gt; a = Hosh(b&#34;a&#34;)
    &gt;&gt;&gt; a[-1].rev == a
    True
    &gt;&gt;&gt; a[0, 1] == a
    True
    &gt;&gt;&gt; a[0:, 1][0] == a
    True
    &gt;&gt;&gt; a[:1, 1][0] == a
    True
    &gt;&gt;&gt; a[0:1, 1][0] == a
    True
    &gt;&gt;&gt; from operator import mul
    &gt;&gt;&gt; reduce(mul, a[:, 3]) == a
    True
    &gt;&gt;&gt; [x.id for x in a[:, 3]]
    [&#39;Bd6Axil5pFSp15HUBz8eCujvu3gBsEk6XMpRsMNo&#39;, &#39;32MloLPcivDbbPMCJn1RBY31aNZ6z-Dqnt4vQhot&#39;, &#39;la3xnZmlhn3lFBAnvWw-UWAvK.2hk-QqUNFYAs3e&#39;]
    &gt;&gt;&gt; a[:, 3][0] * a[:, 3][1] * a[:, 3][2] == a
    True
    &gt;&gt;&gt; a[0, 3] * a[1, 3] * a[2, 3] == a
    True
    &gt;&gt;&gt; a.id
    &#39;cIXBKPediDiOKabeZ6SthD04rnzaquNXaAEhSud4&#39;
    &gt;&gt;&gt; from operator import add, mul
    &gt;&gt;&gt; from functools import reduce
    &gt;&gt;&gt; print(&#34;\n&#34;.join(x.id for x in a.components(0, 7, 7)))
    Bd6Axil5pFSp15HUBz8eCujvu3gBsEk6XMpRsMNo
    32MloLPcivDbbPMCJn1RBY31aNZ6z-Dqnt4vQhot
    Y2JlyuF8.KJc0DvvcIivLA5uLYloF7HN9ovO14Sq
    6.F-NB-G4vBXs7evbBImex9x3foNi85Ca7wDb1c3
    tZmUsjVcZAGTajUOzsSNrr7a7BQVNSiA6xaiPEYf
    iCLMdAlduXvUtK1.awng0D0YP49kV8Cit7OLXyab
    BA6UvITsIN822llT9eErc1R0rmf.ARbc0adwEbWk
    &gt;&gt;&gt; reduce(mul, a.components(0, 2, 7)) * reduce(mul, a.components(2, 3, 7)) * reduce(mul, a.components(3, 7, 7)) == a
    True
    &gt;&gt;&gt; reduce(mul, a.components(0, 7, 7)) == a
    True

    &gt;&gt;&gt; print(&#34;\n&#34;.join(x.id for x in a.components(0, 7, 7, additive=True)))
    Bd6Axil5pFSp15HUBz8eCujvu3gBsEk6XMpRsMNo
    32MloLPcivDbbPMCJn1RBY31aNZ6z-Dqnt4vQhot
    Y2JlyuF8.KJc0DvvcIivLA5uLYloF7HN9ovO14Sq
    6.F-NB-G4vBXs7evbBImex9x3foNi85Ca7wDb1c3
    tZmUsjVcZAGTajUOzsSNrr7a7BQVNSiA6xaiPEYf
    iCLMdAlduXvUtK1.awng0D0YP49kV8Cit7OLXyab
    7jJmsfrPpa2CeeYCAiByF3HW2J9.ARbc0adwEbWk
    &gt;&gt;&gt; reduce(add, a.components(0, 2, 7, additive=True)) + reduce(add, a.components(2, 3, 7, additive=True)) + reduce(add, a.components(3, 7, 7, additive=True)) == a
    True
    &gt;&gt;&gt; reduce(add, a.components(0, 7, 7, additive=True)) == a
    True
    &#34;&#34;&#34;
    if stop &gt; n:  # pragma: no cover
        raise Exception(f&#34;Wrong value:   stop=`{stop}`  &gt;=  n=`{n}`&#34;)
    acc = self.ø
    operator = add if additive else mul
    for i in range(0, stop):
        if stop == n and i == stop - 1:
            break
        if (t := (i, n, additive)) not in self._composition_memo:
            self._composition_memo[t] = Hosh(f&#34;{self.id}-{i}&#34;.encode(), version=self.version)
            if len(self._composition_memo) &gt; self.components_cache_size:  # pragma: no cover
                first = next(iter(self._composition_memo))
                del self._composition_memo[first]
        h = self._composition_memo[t]
        acc = operator(acc, h)
        if i &gt;= start:
            yield h
    if stop == n:
        inv = Hosh(cellsinv(acc.cells, self.p, additive), version=self.version)
        last = operator(inv, self)
        yield last</code></pre>
</details>
</dd>
<dt id="hosh.hosh_.Hosh.convert"><code class="name flex">
<span>def <span class="ident">convert</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"><p>Usage:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from hosh import ø
&gt;&gt;&gt; ø.convert([0,0,0,0,0,0]).id
'0000000000000000000000000000000000000000'
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; from hosh import Hosh
&gt;&gt;&gt; ø.convert(0).id
'0000000000000000000000000000000000000000'
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>other</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convert(self, other):
    &#34;&#34;&#34;
    Usage:

    &gt;&gt;&gt; from hosh import ø
    &gt;&gt;&gt; ø.convert([0,0,0,0,0,0]).id
    &#39;0000000000000000000000000000000000000000&#39;

    &gt;&gt;&gt; from hosh import Hosh
    &gt;&gt;&gt; ø.convert(0).id
    &#39;0000000000000000000000000000000000000000&#39;

    Parameters
    ----------
    other

    Returns
    -------

    &#34;&#34;&#34;
    if isinstance(other, str):
        other = Hosh.fromid(other)
    elif isinstance(other, bytes):
        other = Hosh(other, etype=self.etype_inducer, version=self.version)
    elif isinstance(other, int):
        other = Hosh.fromn(other, version=self.version)
    elif isinstance(other, (tuple | list)):
        other = Hosh(other, version=self.version)
    elif not isinstance(other, Hosh):
        return NotImplemented
    if self.version != other.version:
        raise WrongVersion(f&#34;Incompatible operands: {self.version} != {other.version}&#34;)
    return other</code></pre>
</details>
</dd>
<dt id="hosh.hosh_.Hosh.power_component"><code class="name flex">
<span>def <span class="ident">power_component</span></span>(<span>self, i, n)</span>
</code></dt>
<dd>
<div class="desc"><p>Elements corresponding to <code>n</code> components of "multiplicative decomposition" such that
<code>x
=
x1 * x2 * x3 * ... * xn
=
x * x² * x³ * ... * x^n</code></p>
<p>Not very useful as the resulting elements commute among themselves.
This happens because they are all powers of x, making up just a sequence of <code>x</code>s .</p>
<h1 id="parameters">Parameters</h1>
<p>i
Desired component index
n
Desired total number of components</p>
<h1 id="returns">Returns</h1>
<pre><code>Hosh (component)
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; a = Hosh(b&quot;a&quot;)
&gt;&gt;&gt; a.power_component(0, 1) == a
True
&gt;&gt;&gt; a.power_component(0, 2) * a.power_component(1, 2) == a
True
&gt;&gt;&gt; a.power_component(0, 3) * a.power_component(1, 3) * a.power_component(2, 3) == a
True
&gt;&gt;&gt; a.power_component(2, 3) * a.power_component(1, 3) * a.power_component(0, 3) == a
True
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def power_component(self, i, n):
    &#34;&#34;&#34;Elements corresponding to `n` components of &#34;multiplicative decomposition&#34; such that
    `x  =  x1 * x2 * x3 * ... * xn  =  x * x² * x³ * ... * x^n`

    Not very useful as the resulting elements commute among themselves.
    This happens because they are all powers of x, making up just a sequence of `x`s .

    Parameters
    ==========
    i
        Desired component index
    n
        Desired total number of components

    Returns
    =======
        Hosh (component)

    &gt;&gt;&gt; a = Hosh(b&#34;a&#34;)
    &gt;&gt;&gt; a.power_component(0, 1) == a
    True
    &gt;&gt;&gt; a.power_component(0, 2) * a.power_component(1, 2) == a
    True
    &gt;&gt;&gt; a.power_component(0, 3) * a.power_component(1, 3) * a.power_component(2, 3) == a
    True
    &gt;&gt;&gt; a.power_component(2, 3) * a.power_component(1, 3) * a.power_component(0, 3) == a
    True
    &#34;&#34;&#34;
    if i &gt;= n:  # pragma: no cover
        raise Exception(f&#34;Hosh component should be defined by &#39;index&#39; ({i}) &lt; &#39;#components&#39; ({n})&#34;)
    if n == 1:
        return self
    exp = n * (n + 1) // 2
    r = self.root(exp)
    return r ^ (i + 1)</code></pre>
</details>
</dd>
<dt id="hosh.hosh_.Hosh.root"><code class="name flex">
<span>def <span class="ident">root</span></span>(<span>self, k)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; a = Hosh(b&quot;a&quot;)
&gt;&gt;&gt; for i in range(1, 5):
...     r = a.root(i)
...     r^i == a
True
True
True
True
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def root(self, k):
    &#34;&#34;&#34;
    &gt;&gt;&gt; a = Hosh(b&#34;a&#34;)
    &gt;&gt;&gt; for i in range(1, 5):
    ...     r = a.root(i)
    ...     r^i == a
    True
    True
    True
    True
    &#34;&#34;&#34;
    if k == 1:
        return self
    return Hosh(cellsroot(self.cells, k, self.p), version=self.version)</code></pre>
</details>
</dd>
<dt id="hosh.hosh_.Hosh.short"><code class="name flex">
<span>def <span class="ident">short</span></span>(<span>self, colored=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Usage:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; Hosh(b&quot;asdf86fasd&quot;).short(colored=False)
lϊӑơӫǯÃϺŮϳȐŁЬĽҪƉǏԛȪƜfÞӠȕՇ
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def short(self, colored=True):
    &#34;&#34;&#34;
    Usage:

    &gt;&gt;&gt; Hosh(b&#34;asdf86fasd&#34;).short(colored=False)
    lϊӑơӫǯÃϺŮϳȐŁЬĽҪƉǏԛȪƜfÞӠȕՇ
    &#34;&#34;&#34;
    return print(self.sansi if colored else self.sid)</code></pre>
</details>
</dd>
<dt id="hosh.hosh_.Hosh.show"><code class="name flex">
<span>def <span class="ident">show</span></span>(<span>self, colored=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Usage:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; Hosh(b&quot;asdf86fasd&quot;).show(colored=False)
voh8t1KrYmzCqpyrUO9.5QbGdouoZsnExarMSa34
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show(self, colored=True):
    &#34;&#34;&#34;
    Usage:

    &gt;&gt;&gt; Hosh(b&#34;asdf86fasd&#34;).show(colored=False)
    voh8t1KrYmzCqpyrUO9.5QbGdouoZsnExarMSa34
    &#34;&#34;&#34;
    return print(self.ansi if colored else self.id)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="hosh" href="index.html">hosh</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="hosh.hosh_.Hosh" href="#hosh.hosh_.Hosh">Hosh</a></code></h4>
<ul class="">
<li><code><a title="hosh.hosh_.Hosh.ansi" href="#hosh.hosh_.Hosh.ansi">ansi</a></code></li>
<li><code><a title="hosh.hosh_.Hosh.bad_additive_component" href="#hosh.hosh_.Hosh.bad_additive_component">bad_additive_component</a></code></li>
<li><code><a title="hosh.hosh_.Hosh.bad_additive_components" href="#hosh.hosh_.Hosh.bad_additive_components">bad_additive_components</a></code></li>
<li><code><a title="hosh.hosh_.Hosh.bits" href="#hosh.hosh_.Hosh.bits">bits</a></code></li>
<li><code><a title="hosh.hosh_.Hosh.components" href="#hosh.hosh_.Hosh.components">components</a></code></li>
<li><code><a title="hosh.hosh_.Hosh.components_cache_size" href="#hosh.hosh_.Hosh.components_cache_size">components_cache_size</a></code></li>
<li><code><a title="hosh.hosh_.Hosh.convert" href="#hosh.hosh_.Hosh.convert">convert</a></code></li>
<li><code><a title="hosh.hosh_.Hosh.etype" href="#hosh.hosh_.Hosh.etype">etype</a></code></li>
<li><code><a title="hosh.hosh_.Hosh.etype_inducer" href="#hosh.hosh_.Hosh.etype_inducer">etype_inducer</a></code></li>
<li><code><a title="hosh.hosh_.Hosh.fromid" href="#hosh.hosh_.Hosh.fromid">fromid</a></code></li>
<li><code><a title="hosh.hosh_.Hosh.fromn" href="#hosh.hosh_.Hosh.fromn">fromn</a></code></li>
<li><code><a title="hosh.hosh_.Hosh.fromtensor" href="#hosh.hosh_.Hosh.fromtensor">fromtensor</a></code></li>
<li><code><a title="hosh.hosh_.Hosh.html" href="#hosh.hosh_.Hosh.html">html</a></code></li>
<li><code><a title="hosh.hosh_.Hosh.id" href="#hosh.hosh_.Hosh.id">id</a></code></li>
<li><code><a title="hosh.hosh_.Hosh.idc" href="#hosh.hosh_.Hosh.idc">idc</a></code></li>
<li><code><a title="hosh.hosh_.Hosh.n" href="#hosh.hosh_.Hosh.n">n</a></code></li>
<li><code><a title="hosh.hosh_.Hosh.power_component" href="#hosh.hosh_.Hosh.power_component">power_component</a></code></li>
<li><code><a title="hosh.hosh_.Hosh.rev" href="#hosh.hosh_.Hosh.rev">rev</a></code></li>
<li><code><a title="hosh.hosh_.Hosh.rgb" href="#hosh.hosh_.Hosh.rgb">rgb</a></code></li>
<li><code><a title="hosh.hosh_.Hosh.root" href="#hosh.hosh_.Hosh.root">root</a></code></li>
<li><code><a title="hosh.hosh_.Hosh.sansi" href="#hosh.hosh_.Hosh.sansi">sansi</a></code></li>
<li><code><a title="hosh.hosh_.Hosh.short" href="#hosh.hosh_.Hosh.short">short</a></code></li>
<li><code><a title="hosh.hosh_.Hosh.show" href="#hosh.hosh_.Hosh.show">show</a></code></li>
<li><code><a title="hosh.hosh_.Hosh.shtml" href="#hosh.hosh_.Hosh.shtml">shtml</a></code></li>
<li><code><a title="hosh.hosh_.Hosh.sid" href="#hosh.hosh_.Hosh.sid">sid</a></code></li>
<li><code><a title="hosh.hosh_.Hosh.sidc" href="#hosh.hosh_.Hosh.sidc">sidc</a></code></li>
<li><code><a title="hosh.hosh_.Hosh.ø" href="#hosh.hosh_.Hosh.ø">ø</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>